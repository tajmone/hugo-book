// *****************************************************************************
// *                                                                           *
// *         Hugo Book II: 2/16 -- 14. Organization of the .HEX File           *
// *                                                                           *
// *****************************************************************************
//
[[chapter_14]]
= Organization of the .HEX File

// >>> footnotes definitions >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

:fn1: footnote:[Previously to version 3.1, the size of the grammar and executable code segment was limited to 256K, and the maximum size was 17024K.]

:fn2: footnote:[ \
The version format was changed between v2.0 and v2.1. \
Version 2.0 programs contained the value 2; version 2.1 programs contain the value 21, version 2.2 programs contain 22, etc.]

:fn3: pass:q[footnote:[ \
Pre-v2.3 allowed the programmer to specify an ID string, an unnecessary convention now -- the ID string used to be used to create the default savefile name. \
The ID string is now auto-generated by the compiler and is compared by the engine to the ID of a saved game to see if they match. \
Precompiled headers have the ID string `$$`.]]

:fn4: footnote:[Table offsets are equal to the offset of the beginning of the table from the start of data, divided by 16.]

:fn5: pass:q[footnote:[Pre-v2.5 had no `Perform` junction routine; verb routines were called directly by the engine.]]

// @XREF: "H: Code Patterns" (in footnote!)
:fn6: pass:q[footnote:[ \
For another example, see xref:appendix_h[]. \
Several of the conditional statements -- `if`, `elseif`, etc. -- use two bytes to give the absolute skip distance to the next statement if the conditional test fails. \
The pair is coded in low-byte/high-byte order.]]

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

[[sec_14-1]]
== Memory Map

If all the separate segments of a *.HEX* file were stacked contiguously on top of each other, the resulting pile would look something like this:

[.center,cols="<,>",options="autowidth",stripes=even]
|===============================================================================
| DATA STORAGE:                 | MAXIMUM SIZE:

| (Link data for *.HLB* files)  |
| Text bank                     | 16384K
| Dictionary                    |    64K
| Special words                 |    64K
| Array space                   |    64K
| Event table                   |    64K
| Property table                |    64K
| Object table                  |    64K
| Grammar and Executable code   |  1024K
| Header                        |      64 bytes
2+^| (Bottom: `$000000`) +
 +
MAXIMUM SIZE: 17792K bytes{wj}{fn1}
|===============================================================================

Each new segment begins on a boundary divisible by 16; an end-of-segment is padded with zeroes until the next boundary.
For each segment, data is general stored in sequential chunks, following two or more bytes giving information about the size of the table.

*Dictionary table:* the first two bytes give the total number of entries.
The third byte is always 0, so that dictionary entry 0 is an empty string (`+""+`).
Following the dictionary table, a number of bytes may optionally be written for runtime dictionary expansion (where `$MAXDICTEXTEND` is specified at compile-time).

*Special words:* the first two bytes give the total number of special words.

*Array space:* the first 480 bytes give the global variable defaults (2 bytes each).
For each array entry, the first two bytes give the array length.

*Event table:* the first two bytes give the total number of events.

*Property table:* the first two bytes give the total number (_n_) of properties.
The following _n_*2 bytes give the property defaults.

*Object table:* the first two bytes give the total number of objects.


[[sec_14-2]]
== The Header

The header is reserved a total of 64 bytes at the start of the compiled *.HEX* file, immediately preceding the grammar table.
It contains the bulk of information regarding table offsets, junction routine addresses, etc.: essentially, it is a map to where to find things in the file.

Compile with the `-u` switch to display a map of memory usage in the *.HEX* file that reflects the offsets and addresses encoded in the header.

[cols=">m,>d,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| Byte | Length | Description

| $00 | 1 | Version of Hugo Compiler used{wj}{fn2}
| 01  | 2 | ID string (compiler-generated){wj}{fn3}
| 03  | 8 | Serial number
3+^a| {blank}
| 0B  | 2 | Address of start of executable code
3+^a| {blank}
| 0D  | 2 | Object table offset{wj}{fn4}
| 0F  | 2 | Property table offset
| 11  | 2 | Event table offset
| 13  | 2 | Array space offset
| 15  | 2 | Dictionary offset
| 17  | 2 | Special words table offset
3+^a| {blank}
| 19  | 2 | `Init` routine indexed address
| 1B  | 2 | `Main` routine indexed address
| 1D  | 2 | `Parse` routine indexed address
| 1F  | 2 | `ParseError` routine indexed address
| 21  | 2 | `FindObject` routine indexed address
| 23  | 2 | `EndGame` routine indexed address
| 25  | 2 | `SpeakTo` routine indexed address
| 27  | 2 | `Perform` routine indexed address{wj}{fn5}
3+^a| {blank}
| 29  | 2 | Text bank offset
|===============================================================================
// 3+<d| In *.HDX* (debuggable) Hugo executables only:
// | 3A  | 1 | Debuggable flag, set to 1
// | 3B  | 3 | Absolute start of debugging information
// | 3E  | 2 | Debug workspace (in array table)
// |===============================================================================


In *.HDX* (debuggable) Hugo executables only:

[cols=">m,>d,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| Byte | Length | Description

| 3A  | 1 | Debuggable flag, set to 1
| 3B  | 3 | Absolute start of debugging information
| 3E  | 2 | Debug workspace (in array table)
|===============================================================================


[TIP]
================================================================================
*A note on data storage:* whenever 16-bit words (i.e., two bytes representing a single value) are written or read, it is in low-byte/high-byte order, with the first byte being the remainder of _x_/256 (or the modulus _x_%256), and the second byte being the integer value _x_/256.{wj}{fn6}
================================================================================


// EOF //
