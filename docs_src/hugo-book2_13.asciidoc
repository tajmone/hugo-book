// *****************************************************************************
// *                                                                           *
// *      Hugo Book II: 13/16 -- 25. The Hugo Compiler and How It Works        *
// *                                                                           *
// *****************************************************************************
//
= The Hugo Compiler and How It Works

For reference, here is a simplified map of the compiler's function calls, along with the source files in which they are located.
The leftmost functions are all called from `main()` in *hc.c*:

image::hugo-book2_13_flowchart-compiler.svg[align="center",width=50%]

In *Pass 1*, the initial source file and any included files are read into one contiguous temporary file (called `allfile` in the source).
Any compiler directives (i.e., lines beginning with `#`, `$` or `@`) are processed here [.red]##[1.1]##, as are definitions of objects, attributes, properties, global variables, constants, and routines [.red]##[1.2]##.
Once a line of source has been parsed and split into discrete words, it is written to `allfile` using `PrinttoAll()`.

*Pass 2* is where the bulk of compilation takes place.
Lines of pre-parsed source are read from `allfile`.
After Pass 1, all symbols (except local variables) are known.
Individual constructs such as verbs, objects, routines, and events are processed via `Build...()` functions (i.e., `BuildVerb()`, `BuildObject()`, etc.) [.red]#[2.1]#.

At any point in `Pass2()`, the tokenized line currently being processed is held in the global `word[]` array, with the number of tokens in the current line in `words`.

Sections of executable code, such as routines, events, or property routines, are generated by calling `BuildCode()` [.red]#[2.3]#, which in turn calls appropriate `Code...()` functions as necessary (i.e., `CodeDo()`, `CodeIf()`, `CodeWhile()`, etc.), or simply `CodeLine()` for any line that doesn't require special treatment [.red]#[2.4]#.
Compiled byte-code is emitted to the objectfile via `WriteCode()` [.red]#[2.5]#.

[NOTE]
================================================================================
In a departure from the normal order of defining symbols, synonyms, compounds words, removals, and user-defined punctuation are defined in `Pass2()`.
Local variables are defined in `BuildCode()`.
================================================================================


By *Pass 3*, all executable code has been written to the objectfile, structures exist in memory representing to-be-constructed tables, and the text bank (long sections of printed text) exists in a temporary file.
First, `ResolveAddr()` (from *hcmisc.c*) patches all references that were unknown at the time they were compiled.
`Pass3()` then writes the object table, the property table, the event table, the array table, synonyms/removals/compounds/user-defined punctuation, the dictionary, and the text bank.

If a debuggable executable (called an .HDX file) is being generated, the last thing `Pass3()` does is to write the symbolic names of all objects, properties, attributes, aliases, globals, routines, events, and arrays to the end of the file.


== Compile-Time Symbol Data

Here are the various structures, arrays, and variables used by the compiler to keep track of symbols at compile-time:

[caption=]
.Objects:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| objctr         | total number of objects
| object[n]      | symbolic name of object _n_
| object_hash[n] | hash value of symbol name
| objattr[n][s]  | attribute set _s_ (32 attributes/set)
| oprop[n]       | location in `propdata[]` array
| objpropaddr[n] | location in property table
| parent[n]      | physical parent
| sibling[n]     | physical sibling
| child[n]       | physical child
| oreplace[n]    | number of times replaced using the `replace` directive
|===============================================================================


[caption=]
.Attributes:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| attrctr total     | number of attributes
| attribute[n]      | symbolic name of attribute _n_
| attribute_hash[n] | hash value of symbol name
|===============================================================================


[caption=]
.Properties:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| propctr          | total number of properties
| property[n]      | symbolic name of property _n_
| property_hash[n] | hash value of symbol name
| propset[p]       | true if property _p_ has been defined for current object
| propadd[p]       | `ADDITIVE_FLAG` bit is true if property _p_ is additive; +
| COMPLEX_FLAG     | bit is true if property _p_ is a complex property
| propdata[a][b]   | array of all property data
| propheap         | size of property table
|===============================================================================


[caption=]
.Labels:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| labelctr      | total number of labels
| label[n]      | symbolic name of label _n_
| label_hash[n] | hash value of symbol name
| laddr[n]      | indexed address of label
|===============================================================================


[caption=]
.Routines:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| routinectr      | total number of routines
| routine[n]      | symbolic name of routine _n_
| routine_hash[n] | hash value of symbol name
| raddr[n]        | indexed address of routine
| rreplace[n]     | number of times replaced using the `replace` directive
|===============================================================================


[caption=]
.Events (although not really symbols):
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| eventctr     | total number of events
| eventin[n]   | object to which event _n_ is attached
| eventaddr[n] | indexed address of event code
|===============================================================================


[caption=]
.Aliases:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| aliasctr      | total number of aliases
| alias[n]      | symbolic name of alias _n_
| alias_hash[n] | hash value of symbol name
| aliasof[n]    | attribute or property aliased +
(either the attribute number, or the property number plus `MAXATTRIBUTES`)
|===============================================================================


[caption=]
.Global variables:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| globalctr      | total number of global variables
| global[n]      | symbolic name of global _n_
| global_hash[n] | hash value of symbol name
| globaldef[n]   | initial value of global at startup
|===============================================================================


[caption=]
.Local variables:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| localctr      | total number of locals defined in the current code block
| local[n]      | symbolic name of local _n_
| local_hash[n] | hash value of symbol name
| unused[n]     | true until local _n_ is used
|===============================================================================


[caption=]
.Constants:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| constctr         | total number of constants
| constant[n]      | symbolic name of constant _n_
| constant_hash[n] | hash value of symbol name
| constantval[n]   | defined value of constant
|===============================================================================


[caption=]
.Array:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| arrayctr      | total number of arrays
| array[n]      | symbolic name of array _n_
| array_hash[n] | hash value of symbol name
| arrayaddr[n]  | location in array table
| arraylen[n]   | length of array _n_
| arraysize     | current size of array table
|===============================================================================


[caption=]
.Dictionary:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| dictcount   | total number of dictionary entries
| dicttable   | current size of dictionary
| lexentry[n] | dictionary entry _n_
| lexaddr[n]  | location of entry _n_ in dictionary table
| lexnext[n]  | location of word following _n_ in the `lexentry[]` array
| lexstart[c] | location of first word beginning with character _c_ in `lexentry[]`
| lexlast[c]  | location of last word beginning with character _c_ in `lexentry[]`
|===============================================================================


[caption=]
.Special words:
[cols="<m,<d",options=autowidth,grid=none,stripes=even]
|===============================================================================
| syncount   | total number of synonyms, compounds, removals, and user-defined punctuation
| syndata[n] | `synstruct` structure of _n_
|===============================================================================


The use of ``...++_hash[n]++`` is a rough form of hash-table coding.
The compiler, in `FindHash()` in *hcdef.c*, produces an _almost_ unique value for a given symbol based on the characters in it.
Only if `...++_hash[n]++` matches an expected value does a more expensive `strcmp()` string comparison have to be performed to validate the "`match`" (or reject it).


== The Linker

The compiler has to be able to both create a linkable file (called an .HLB file, as it is usually a precompiled version of the library) and read it back when a `#link` directive is encountered.

In the first case, the compiler writes an .HLB file whenever the `-h` switch is set at invocation.
In order to do that, it does the following things:

[arabic]
. Property routines, normally marked by a "`length`" of 255, are changed to a "`length`" of 254.
. All addresses are appended to the end of the file instead of being resolved in `Pass3()`. (Labels, being local and therefore not visible outside the .HLB file, are an exception; they are resolved as usual.)
. Additional data (such as symbolic names) of objects and properties are written in `Pass3()`.
Immediately following the object table, the compiler, in `Pass3()`, writes all the relevant data for attributes, aliases, globals, constants, routines.
. The value `$$` is written into the ID string in the header.

Reading back (i.e., linking) an .HLB file is done in two steps: `LinkerPass1()` [.red]#[1.3]#, called from `Pass1()`, and `LinkerPass2()` [.red]#[2.2]#, called from `Pass2()`. (The linker routines are found in the source file *hclink.c*.)

`LinkerPass1()` simply skims the .HLB file for symbols and defines them accordingly, along with any relevant data.
It also reads the .HLB file's text bank and writes it to the current file's temporary file containing the current text bank.
Note that since linking must be done before any other definitions, there is no need to calculate offsets here for things like object numbers, addresses in the text bank, etc.

`LinkerPass2()` is responsible for reading the actual executable code.
It does this mainly with a simple read/write (in blocks of 16K or smaller).
It then reads the resolve table appended to the end of the .HLB file and writes it to the current resolve table so that `Pass3()` can properly resolve the offset code addresses at the end of compilation.

[NOTE]
================================================================================
Since the actual start of executable code will vary depending on the length of the grammar table, it is not known at the .HLB file's compile-time what a given address may ultimately be.
It is only known that, for example, routine _R_ is called from position _P_ in the source.
Both _R_ and _P_ must be adjusted for the offset.
================================================================================

In `Pass3()`, `ResolveAddr()` is now able to resolve addresses from the linked file.
Additionally, those properties with a "`length`" of 254 are adjusted so that their values--which are really addresses of property routines--are adjusted as per the offset; the "`length`" of these properties is then written as 255.


// EOF //
