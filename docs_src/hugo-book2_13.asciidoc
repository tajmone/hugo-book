= THE HUGO COMPILER AND HOW IT WORKS



For reference, here is a simplified map of the compiler's function calls, along with the source files in which they are located. The leftmost functions are all called from main() in *hc.c*:

..............................................................
+----------------+
| ParseCommand() | - Parse command line, including filenames,
|    hcmisc.c    |   switches, and other settings
+----------------+
        |
+----------------+
|  OpenFiles()   | - Open initial source file, objectfile,
|   hcfile.c     |   listing, and temporary files
+----------------+
        |
+----------------+  +----------------------------------+
|    Pass1()     |  | GetLine()            - hcfile.c  |
|    hcpass.c    |--|                                  |
|                |  | CompilerDirective()  - hccomp.c  | [1.1]
| (Definitions)  |  | CompilerMem()        - hccomp.c  |
+----------------+  | AddDirectory()       - hcmisc.c  |
        |           |                                  |
        |           | Def...()             - hcdef.c   | [1.2]
        |           |                                  |
        |           | PrinttoAll()         - hcmisc.c  |
        |           |                                  |
        |           | (LinkerPass1()       - hclink.c) | [1.3]
        |           +----------------------------------+
        |
        |
+----------------+  +----------------------------+
|    Pass2()     |  | GetWords()     - hcfile.c  |
|    hcpass.c    |--|                            |
|                |  | Build...()     - hcbuild.c | [2.1]
|    (Build)     |  |                            |
+----------------+  | (LinkerPass2() - hclink.c) | [2.2]
        |           +----------------------------+
        |                          |
        |                          |
+----------------+       +--------------------------+
|    Pass3()     |       | BuildCode()  - hcbuild.c | [2.3]
|    hcpass.c    |--+    +--------------------------+
|                |  |                 |
| (Resolve/Link) |  |       +-----------------------+
+----------------+  |       | Code...()  - hccode.c | [2.4]
                    |       | Codeline() - hccode.c |
                    |       +-----------------------+
                    |                      |          [2.5]
                    |             \+------------------------+
                    +--------------| Write...()  - hcfile.c |
                                  /| WriteCode() - hcfile.c |
                                   +------------------------+
..............................................................

In *Pass 1*, the initial source file and any included files are read into one contiguous temporary file (called allfile in the source). Any compiler directives (i.e., lines beginning with `#`, `$` or `@`) are processed here [1.1], as are definitions of objects, attributes, properties, global variables, constants, and routines [1.2]. Once a line of source has been parsed and split into discrete words, it is written to allfile using PrinttoAll().

*Pass 2* is where the bulk of compilation takes place. Lines of pre-parsed source are read from allfile. After Pass 1, all symbols (except local variables) are known. Individual constructs such as verbs, objects, routines, and events are processed via Build...() functions (i.e., BuildVerb(), BuildObject(), etc.) [2.1].

At any point in Pass2(), the tokenized line currently being processed is held in the global word[] array, with the number of tokens in the current line in words.

Sections of executable code, such as routines, events, or property routines, are generated by calling BuildCode() [2.3], which in turn calls appropriate Code...() functions as necessary (i.e., CodeDo(), CodeIf(), CodeWhile(), etc.), or simply CodeLine() for any line that doesn't require special treatment [2.4]. Compiled byte-code is emitted to the objectfile via WriteCode() [2.5].

(In a departure from the normal order of defining symbols, synonyms, compounds words, removals, and user-defined punctuation are defined in Pass2(). Local variables are defined in BuildCode().)

By *Pass 3*, all executable code has been written to the objectfile, structures exist in memory representing to-be-constructed tables, and the text bank (long sections of printed text) exists in a temporary file. First, ResolveAddr() (from *hcmisc.c*) patches all references that were unknown at the time they were compiled. Pass3() then writes the object table, the property table, the event table, the array table, synonyms/removals/compounds/user-defined punctuation, the dictionary, and the text bank.

If a debuggable executable (called an .HDX file) is being generated, the last thing Pass3() does is to write the symbolic names of all objects, properties, attributes, aliases, globals, routines, events, and arrays to the end of the file.

== Compile-Time Symbol Data



Here are the various structures, arrays, and variables used by

the compiler to keep track of symbols at compile-time:

*Objects:*

objctr total number of objects

object[n] symbolic name of object _n_

object_hash[n] hash value of symbol name

objattr[n][s] attribute set _s_ (32 attributes/set)

oprop[n] location in propdata[] array

objpropaddr[n] location in property table

parent[n] physical parent

sibling[n] physical sibling

child[n] physical child

oreplace[n] number of times replaced using the

replace directive

*Attributes:*

attrctr total number of attributes

attribute[n] symbolic name of attribute _n_

attribute_hash[n] hash value of symbol name

*Properties:*

propctr total number of properties

property[n] symbolic name of property _n_

property_hash[n] hash value of symbol name

propset[p] true if property _p_ has been defined

for current object

propadd[p] ADDITIVE_FLAG bit is true if

property _p_ is additive;

COMPLEX_FLAG bit is true if property

_p_ is a complex property

propdata[a][b] array of all property data

propheap size of property table

*Labels:*

labelctr total number of labels

label[n] symbolic name of label _n_

label_hash[n] hash value of symbol name

laddr[n] indexed address of label

*Routines:*

routinectr total number of routines

routine[n] symbolic name of routine _n_

routine_hash[n] hash value of symbol name

raddr[n] indexed address of routine

rreplace[n] number of times replaced using the

replace directive

*Events (although not really symbols):*

eventctr total number of events

eventin[n] object to which event _n_ is attached

eventaddr[n] indexed address of event code

*Aliases:*

aliasctr total number of aliases

alias[n] symbolic name of alias _n_

alias_hash[n] hash value of symbol name

aliasof[n] attribute or property aliased

(either the attribute number, or

the property number plus

MAXATTRIBUTES)

*Global variables:*

globalctr total number of global variables

global[n] symbolic name of global _n_

global_hash[n] hash value of symbol name

globaldef[n] initial value of global at startup

*Local variables:*

localctr total number of locals defined in the

current code block

local[n] symbolic name of local _n_

local_hash[n] hash value of symbol name

unused[n] true until local _n_ is used

*Constants:*

constctr total number of constants

constant[n] symbolic name of constant _n_

constant_hash[n] hash value of symbol name

constantval[n] defined value of constant

*Array:*

arrayctr total number of arrays

array[n] symbolic name of array _n_

array_hash[n] hash value of symbol name

arrayaddr[n] location in array table

arraylen[n] length of array _n_

arraysize current size of array table

*Dictionary:*

dictcount total number of dictionary entries

dicttable current size of dictionary

lexentry[n] dictionary entry _n_

lexaddr[n] location of entry n in dictionary

table

lexnext[n] location of word following n in the

lexentry[] array

lexstart[c] location of first word beginning with

character _c_ in lexentry[]

lexlast[c] location of last word beginning with

character _c_ in lexentry[]

*Special words:*

syncount total number of synonyms, compounds,

removals, and user-defined

punctuation

syndata[n] synstruct structure of _n_

The use of ..._hash[n] is a rough form of hash-table coding. The compiler, in FindHash() in *hcdef.c*, produces an _almost_ unique value for a given symbol based on the characters in it. Only if ..._hash[n] matches an expected value does a more expensive strcmp() string comparison have to be performed to validate the "`match`" (or reject it).

== The Linker



The compiler has to be able to both create a linkable file (called an .HLB file, as it is usually a precompiled version of the library) and read it back when a #link directive is encountered.

In the first case, the compiler writes an .HLB file whenever the -h switch is set at invocation. In order to do that, it does the following things:

[arabic]
. Property routines, normally marked by a "`length`" of 255, are changed to a "`length`" of 254.
. All addresses are appended to the end of the file instead of being resolved in Pass3(). (Labels, being local and therefore not visible outside the .HLB file, are an exception; they are resolved as usual.)
. Additional data (such as symbolic names) of objects and properties are written in Pass3(). Immediately following the object table, the compiler, in Pass3(), writes all the relevant data for attributes, aliases, globals, constants, routines.
. The value `$$` is written into the ID string in the header.

Reading back (i.e., linking) an .HLB file is done in two steps: LinkerPass1() [1.3], called from Pass1(), and LinkerPass2()[2.2], called from Pass2(). (The linker routines are found in the source file *hclink.c*.)

LinkerPass1() simply skims the .HLB file for symbols and defines them accordingly, along with any relevant data. It also reads the .HLB file's text bank and writes it to the current file's temporary file containing the current text bank. Note that since linking must be done before any other definitions, there is no need to calculate offsets here for things like object numbers, addresses in the text bank, etc.

LinkerPass2() is responsible for reading the actual executable code. It does this mainly with a simple read/write (in blocks of 16K or smaller). It then reads the resolve table appended to the end of the .HLB file and writes it to the current resolve table so that Pass3() can properly resolve the offset code addresses at the end of compilation. (Since the actual start of executable code will vary depending on the length of the grammar table, it is not known at the .HLB file's compile-time what a given address may ultimately be. It is only known that, for example, routine _R_ is called from position _P_ in the source. Both _R_ and _P_ must be adjusted for the offset.)

In Pass3(), ResolveAddr() is now able to resolve addresses from the linked file. Additionally, those properties with a "`length`" of 254 are adjusted so that their values--which are really addresses of property routines--are adjusted as per the offset; the "`length`" of these properties is then written as 255.


// EOF //
