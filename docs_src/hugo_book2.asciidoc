// *****************************************************************************
// *                                                                           *
// *                 BOOK 2 -- TECHNICAL SYSTEM SPECIFICATION                  *
// *                                                                           *
// *****************************************************************************

= BOOK 2: TECHNICAL SYSTEM SPECIFICATION

// BOOK 2 +
// TECHNICAL SYSTEM SPECIFICATION

[.text-center.partsubtitle]
OR +
UNDER THE HOOD OF HUGO AND THE .HEX FILE FORMAT

== INTRODUCTION



Most Hugo programmers will likely never need to bother with the detailed information in this technical guide, but anyone porting Hugo to a new platform, writing an interface or tool for the language, or just interested in taking a closer look at how the Hugo Compiler generates a compiled program (and how the Hugo Engine interprets it) might find a technical specification useful, even if only to verify the occasional behavior or detail. What this look under the hood attempts to do is to outline the configuration of data and code storage used by Hugo, as well as giving an extensive overview of how the various aspects of the language are compiled and interpreted.

This technical specification of the language internals is not a complete programming guide; familiarity with the language and a handy copy of the Hugo Programming Manual will be helpful, as will access to the Hugo source code (written in ANSI C and available at the time of this writing at _ftp://ftp.ifarchive.org/if-archive/programming/hugo/source_).

The standard Hugo source distribution is *hugov31_source.tar.gz*. Operating-system-specific sources (i.e., implementations of non-portable functions) are typically *hugov31_OSname_source.zip*.

Please note that while this document does address differences between the current version of Hugo and previous versions, it is by no means complete in that respect. For example, a current-version implementation of the Hugo Engine that conforms to this specification is not guaranteed to run programs compiled with all previous versions of Hugo. For further elaboration on such differences, please see the Hugo source itself.

=== How Hugo Works



The Hugo system is composed of two parts: the compiler and the engine (the interpreter). (The debugger is actually a modified build of the engine, with an additional command layer to facilitate debugging examination and manipulation of the runtime state.)

The compiler is responsible for reading source files and writing executable code; it does this by first tokenizing a given line of code--breaking it down into a series of byte values representing its contents--and then determining how the line(s) should be written (i.e., identified, optimized, and encoded) in order to fit properly into the current construct. The compiler is also responsible for organizing and writing tables representing object data, property data, the dictionary, etc.

The engine in turn reads the file produced by the compiler (called a .HEX file, after the default extension), and follows the compiled instructions to execute low-level functions such as object movement, property assignment, text output, and expression evaluation. These low-level operations are, for the most part, transparent to the programmer.

== ORGANIZATION OF THE .HEX FILE


=== Memory Map



If all the separate segments of a .HEX file were stacked contiguously on top of each other, the resulting pile would look something like this:

DATA STORAGE: MAXIMUM SIZE:

+-----------------+---------------+

| (Link data for | |

| .HLB files) | |

+-----------------+---------------+

| Text bank | 16384K |

+-----------------+---------------+

| Dictionary | 64K |

+-----------------+---------------+

| Special words | 64K |

+-----------------+---------------+

| Array space | 64K |

+-----------------+---------------+

| Event table | 64K |

+-----------------+---------------+

| Property table | 64K |

+-----------------+---------------+

| Object table | 64K |

+-----------------+---------------+

| Grammar and | |

| Executable code | 1024K |

+-----------------+---------------+

| Header | 64 bytes |

+-----------------+---------------+

(Bottom: $000000)

MAXIMUM SIZE: 17792K bytesfootnote:[Previously to version 3.1, the size of the grammar and executable code segment was limited to 256K, and the maximum size was 17024K.]

Each new segment begins on a boundary divisible by 16; an end-of-segment is padded with zeroes until the next boundary. For each segment, data is general stored in sequential chunks, following two or more bytes giving information about the size of the table.

*Dictionary table:* the first two bytes give the total number of entries. The third byte is always 0, so that dictionary entry 0 is an empty string (`+""+`). Following the dictionary table, a number of bytes may optionally be written for runtime dictionary expansion (where $MAXDICTEXTEND is specified at compile-time).

*Special words:* the first two bytes give the total number of special words.

*Array space:* the first 480 bytes give the global variable defaults (2 bytes each). For each array entry, the first two bytes give the array length.

*Event table:* the first two bytes give the total number of events.

*Property table:* the first two bytes give the total number (_n_) of properties. The following _n_*2 bytes give the property defaults.

*Object table:* the first two bytes give the total number of objects.

=== The Header



The header is reserved a total of 64 bytes at the start of the compiled .HEX file, immediately preceding the grammar table. It contains the bulk of information regarding table offsets, junction routine addresses, etc.: essentially, it is a map to where to find things in the file.

Compile with the -u switch to display a map of memory usage in the .HEX file that reflects the offsets and addresses encoded in the header.

*Byte Length Description*

*$00* 1 Version of Hugo Compiler usedfootnote:[The version format was changed between v2.0 and v2.1. Version 2.0 programs contained the value 2; version 2.1 programs contain the value 21, version 2.2 programs contain 22, etc.]

*01* 2 ID string (compiler-generated)footnote:[Pre-v2.3 allowed the programmer to specify an ID string, an unnecessary convention now--the ID string used to be used to create the default savefile name. The ID string is now auto-generated by the compiler and is compared by the engine to the ID of a saved game to see if they match. Precompiled headers have the ID string `$$`.]

*03* 8 Serial number

*0B* 2 Address of start of executable code

*0D* 2 Object table offsetfootnote:[Table offsets are equal to the offset of the beginning of the table from the start of data, divided by 16.]

*0F* 2 Property table offset

*11* 2 Event table offset

*13* 2 Array space offset

*15* 2 Dictionary offset

*17* 2 Special words table offset

*19* 2 Init routine indexed address

*1B* 2 Main routine indexed address

*1D* 2 Parse routine indexed address

*1F* 2 ParseError routine indexed address

*21* 2 FindObject routine indexed address

*23* 2 EndGame routine indexed address

*25* 2 SpeakTo routine indexed address

*27* 2 Perform routine indexed addressfootnote:[Pre-v2.5 had no Perform junction routine; verb routines were called directly by the engine.]

*29* 2 Text bank offset

In .HDX (debuggable) Hugo executables only:

*3A* 1 Debuggable flag, set to 1

*3B* 3 Absolute start of debugging information

*3E* 2 Debug workspace (in array table)

A note on data storage: whenever 16-bit words (i.e., two bytes representing a single value) are written or read, it is in low-byte/high-byte order, with the first byte being the remainder of _x_/256 (or the modulus _x_%256), and the second byte being the integer value _x_/256.footnote:[For another example, see _APPENDIX A:_ _CODE PATTERNS_. Several of the conditional statements--if, elseif, etc.--use two bytes to give the absolute skip distance to the next statement if the conditional test fails. The pair is coded in low-byte/high-byte order.]

== TOKENS AND DATA TYPES



The first two places to start inspecting how the Hugo compiler writes a .HEX file are: (1) what byte values are written to represent each individual token (i.e. keywords, built-in functions, etc.), and (2) how different data types and values are formatted.

=== Tokens



00 (not used) 10 # 20 for

01 ( 11 ~ 21 return

02 ) 12 >= 22 break

03 . 13 <= 23 and

04 : 14 ~= 24 or

05 = 15 & 25 jump

06 - 16 > 26 run

07 + 17 < 27 is

08 * 18 if 28 not

09 / 19 , 29 true

0A | 1A else 2A false

0B ; 1B elseif 2B local

0C \{ 1C while 2C verb

0D } 1D do 2D xverb

0E [ 1E select 2E held

0F ] 1F case 2F multi

30 multiheld 40 eldest 50 window

31 newline 41 younger 51 random

32 anything 42 elder 52 word

33 print 43 prop# 53 locate

34 number 44 attr# 54 parse$

35 capital 45 var# 55 children

36 text 46 dictentry# 56 in

37 graphics 47 textdata# 57 pause

38 color 48 routine# 58 runevents

39 remove 49 label# 59 arraydata#

3A move 4A object# 5A call

3B to 4B value# 5B stringdata#

3C parent 4C eol# 5C save

3D sibling 4D system 5D restore

3E child 4E notheld 5E quit

3F youngest 4F multinotheld 5F input

60 serial$ 70 readfile

61 cls 71 writeval

62 scripton 72 readval

63 scriptoff 73 playback

64 restart 75 colour

65 hex 76 picture

66 object 77 sound

67 xobject 78 music

68 string 79 repeat

69 array 7A addcontextfootnote:[v3.0 and later]

6A printchar 7B videofootnote:[v3.0 and later]

6B undo

6C dict

6D recordon

6E recordoff

6F writefile

Some of these, particularly the early tokens, are as simple as punctuation marks that are recognized by the engine as delimiting expressions, arguments, etc. Non-punctuation stand-alone tokens (to, in, is) are used for similar purposes, to give form to a particular construction. Others, such as save, undo, recordon, and others are engine functions that, when read, trigger a specific action.

Note also tokens ending with `#`: these primarily represent data types that are not directly enterable as part of a program--the `#` character is separated and read as a discrete word in a parsed line of Hugo source. For example, the occurrence of a variable name in the source will be compiled into var# (token $45) followed by two bytes giving the number of the variable being referenced. (See the following section on Data Types for more details.)

=== Data Types



Internally, all data is stored as 16-bit integers (that may be treated as unsigned as appropriate). The valid range is -32768 to 32767.

Following are the formats for the various data types used by Hugo; to see them in practice, it is recommended to consult the Hugo C source code and the functions CodeLine() in *hccode.c*--for writing them in the compiler--and GetValue() and GetVal() in *heexpr.c*--for reading them via the engine.

ATTRIBUTE:

<attr#> <1 byte>

The single byte represents the number of the attribute, which may range from $00 to $7F (0 to 127).

Attribute $10, for example, would be written as:

$44 10

DICTIONARY ENTRY:

<dictentry#> <2 bytes>

The 2 bytes (one 16-bit word) represent the address of the word in the dictionary table. The empty string (`+""+`) is $00.

If the word "`apple`" was stored at the address $21A0, it would be written as:

$46 A0 21

OBJECT:

<object#> <2 bytes>

The two bytes (one 16-bit word) give the object number.

Objects $0002 and $01B0 would be written as, respectively:

$4A 02 00

$4A B0 01

PROPERTY:

<prop#> <1 byte>

The single byte gives the number of the property being referenced.

Property $21 would be written as:

$43 21

ROUTINE:

<routine#> <2 bytes>

The two bytes (one 16-bit word) give the indexed address of the routine. All blocks of executable code begin on an address divisible by 16footnote:[Prior to version 3.1, this scaling factor was 4.]; this allows 1024K of memory to be addressable via the range 0 to 65536. (Code is padded with empty ($00) values to the next address divisible by the address scale.)

For example, a routine beginning at $004004 would be divided by 16 and encoded as the indexed address $0401, in the form:

$48 01 04

This goes for routines, events, property routines, and even conditional code blocks following if, while, etc.

VALUE (i.e., INTEGER CONSTANT):

<value#> <2 bytes>

A value may range from -32768 to 32767; negative numbers follow signed-value 16-bit convention by being _x_ + 65536 where _x_ is a negative number.

For example, the values 10 ($0A), 16384 ($4000), and -2 would be written as:

$4B 0A 00

$4B 00 40

$4B FE FF ($FFFE = 65534 = -2 + 65536)

VARIABLE:

<var#> <1 byte>

A program may have up to 240 global variables (numbered 0 to 239), and 16 local variables for the current routine (numbered 240 to 255). Since 240 + 16 = 256, the number of the variable being specified will fit into a single byte.

In the compiler, the first global variable (i.e. variable 0) is predefined as `object`. It would be written as a sequence of two bytes:

$45 00

A routine's second argument or local would be numbered 241 (since 240 ($F0) is the first local variable), and would be written as:

$45 F1

== ENGINE PARSING



The engine is responsible for all the low-level parsing of an input line (i.e., player command). Upon receiving an input, the engine parses the line into separate words, storing them in the word array. The word array--i.e., that which is referenced in a Hugo program via word[_n_]--is an internal structure coded using the word token instead of array#. A static, read-only parser string called parse$ is used for storage of important data, such as a parser-error-causing word/phrase that cannot otherwise be communicated as an existing dictionary entry.

The first parsing pass also does the following:

[arabic]
. Allows integer numbers for -32768 to 32767.
. Time given in “_hh_:_mm_” (hours:minutes) format is converted to an integer number representing the total minutes since midnight, i.e., through the formula: _hh_ * 60 + _mm_. The original “_hh_:_mm_” is stored in parse$.
. Up to one word (or set of words) in quotation marks is allowed; if found, it is stored in parse$.
. Special words are processed, i.e., removals and user-defined punctuation are removed, compounds are combined, and synonyms are replaced.footnote:[See _XI.b_ _Special Words_]

If a user-defined Parse routine exists (i.e., if bytes $1D-1E in the header are not $0000), it is called next. If the routine returns true, the engine parsing routine is called a second time to reconcile any changes to the word set.

If at any point the parser is unable to continue, either because an unknown word--one not found in the dictionary table--is found, or because there is a problem later, in grammar matching (described below), a parser error is generated, and parsing is stopped. (The unknown or otherwise problem-causing word is stored in parse$.)

The engine has a set of standard parser errors that may be overridden by a user-provided ParseError (i.e., if bytes $1F-20 in the header are not $0000). If there is no ParseError routine, or if ParseError returns false, the default parser error message is printed.

== GRAMMAR



The grammar table starts immediately following the header (at $40, or 64 bytes into the .HEX file). It is used for matching against the player's input line to determine the verbroutine to be called, and if applicable, the object(s) and xobject (i.e, the indirect object).

[NOTE]
================================================================================
If the input line begins with an object instead of a verb--i.e., if it is directed toward a character, as in "`Bob, get the object`", then grammar is matched against the phrase immediately following the initial object.)
================================================================================



The grammar table is comprised of a series of verb or xverb (i.e., non-action verb) blocks, each beginning with either verb ($2C) or xverb ($2D). A $FF value instead of either verb or xverb indicates the end of the grammar table. A grammar table that looks like

000040: FF

has no entries.

Following the verb type indicator is a single byte giving the number of words (i.e., synonyms) for this particular verb. Following that are the dictionary addresses of the individual words.

Think of the simple grammar definition:

verb "get", "take"

* object DoGet

If this were the first verb defined, the start of the grammar table would look like:

000040: 2C 02 x2 x1 y2 y1

where $__x1x2__ is the dictionary address of "`get`", and $__y1y2__ is the dictionary address of "`take`".

With v2.5 was introduced a separate--although rarely used--variation to the verb header. A verb or xverb definition can contain something like

verb get_object

where get_object is an object or some other value. In this case, the verb word is get_object.noun instead of an explicitly defined word. The grammar table in this case would look like”

000040: 2C 01 FF FF 4A x2 x1

where $FFFF is the signal that instead of a dictionary word address, the engine must read the following discrete value, where $4A is the object# token, and $__x1x2__ is the object number of get_object. This extension is provided so that grammar may be dynamically coded and changed at runtime.

Following the verb header giving the number of verb words and the dictionary address of each is one or more grammar lines, each beginning with a `*` signifying the matched verb word. (For an elaboration of valid grammar syntax specification, please see the Hugo Manual.)

Grammar lines are encoded immediately following the verb header, so that in the first example given above,

verb "get", "take"

* object DoGet

becomes:

000040: 2C 02 x2 x1 y2 y1

000046: 08 66 48 r2 r1

00004B: FF

where $r__1r2__ is the indexed routine address of DoGet.

The $FF byte marks the end of the current verb definition. Immediately following this is either another verb or xverb token, or a second $FF to indicate the end of the verb table.

== EXECUTABLE CODE


=== A Simple Program



The following is a simple Hugo program:

routine main

\{

print "Hello, Sailor!"

pause

return

}

It will print "`Hello, Sailor!`", wait for a keypress, and exit. When compiled, the grammar table and executable code look like this:

000040: FF 00 00 00 33 6B 0E 00 5C 79 80 80 83 40 34 67

000050: 75 7D 80 83 86 35 4C 57 21 4C 0D 21 4C 00 00 00

Here is what those 32 bytes represent:

000040: FF

The grammar table is empty; no grammar has been defined. The first entry in the grammar table is $FF, signifying end-of-table.

000041: 00 00 00

Padding to the next address boundary.

000044: 33

A print token.

000045: 5B 0E 00 5C 79 80 80 83 40 34 67 75 7D 80 83 86 35

H e l l o , S a i l o r !

A stringdata# ($5B) token of 14 characters ($000E), followed by the encoded string "`Hello, Sailor!`" (Since this is a print statement, the text is written directly into the code instead of in the text bank.)

000056: 4C

An eol# token, to signal end-of-line for the current print statement.

000057: 57

A pause token.

000058: 21 4C

A return token, followed by eol#. (If there is a value being returned, that expression comes between $21 and $4C. Since in this case the expression is blank--since there is no value being explicitly returned--the $4C comes immediately.)

00005A: 0D 21 4C

The closing brace symbol $0D marks the end of the routine. All routines are automatically followed by a default $21 and $4C--the equivalent of `return false`.

=== Expressions



Expressions are encoded as the tokenized representation of the expression. Consider the following code excerpts, assuming that global initializations have included:

global glob

array arr[10]

and, within the current routine:

local loc

(Assume also that glob and loc are the first global variable and first local variable defined.)

{empty}1. loc = 10

This is coded using the pattern

<var#> <1 byte> = <value#> <2 bytes> <eol#>

so that the resulting code looks like:

45 F0 05 4B 0A 00 4C

loc = 10

The variable number $F0 specifies the first local variable (i.e., local variable 0, where the variable number of local variable _n_ is 240+__n__).

{empty}2. glob = 5 * (2 + 1)

Again, this is coded as a variable assignment:

<var#> <1 byte> = <expression> <eol#>

45 0C 05 4B 05 00 08 01 4B 02 00 07 4B 01 00 02 4C

glob = 5 * ( 2 + 1 )

Since the compiler always defines a number of global variables itself, the first-defined global is never 0. If there are 12 pre-defined globals, the first user-defined global has variable number $0C.

{empty}3. arr[loc] = word[2]

The pattern for this array element assignment is:

<arraydata#> [ <expr> ] = <word> [ <expr> ] <eol#>

59 F0 00 0E 45 F0 0F 05 52 0E 4B 02 00 0F 4C

arr [ loc ] = word [ 2 ]

(Note that word[n] is not handled the same as array[n].)

{empty}4. array[1] = random(obj.prop #2)

(Assuming that obj and prop are the first-defined object and property, respectively.)

<arraydata#> [ <expr> ] = random ( <expr> ) <eol#>

59 F0 00 0E 4B 01 00 0F 05 51

arr [ 1 ] = random

01 4A 00 00 03 43 06 10 4B 02 00 02 4C

( obj . prop # 2 )

{empty}5. glob += (loc++ * arr[7])

45 0C 07 05 01 45 F0 07 07 08

glob + = ( loc + + *

59 F0 00 0E 4B 07 00 0F 02 4C

arr [ 7 ] )

{empty}6. if loc = glob + 11

(See _APPENDIX A:_ _CODE PATTERNS_ for details on how if statements and other conditionals are coded.)

18 21 00 45 F0 05 45 0C 07 4B 0B 00 4C

if loc = glob + 11

2 bytes give the skip distance (i.e., $0021 bytes) to the next-executed instruction if the current expression evaluates false.

== ENCODING TEXT



Text is written uncompressed into the .HEX file (since there is not really any need for nor any great memory savings from whatever minor compression might be practical). All text, however--including text in print statements, dictionary entries, and the text bank--is encoded by adding $14 (decimal 20) to each 8-bit ASCII value in order to prevent casual browsing of game data.

Text in print statements is written directly into the code in the form:

<stringdata#> <2 bytes> ...encoded string...

where the length of the string is given by the first two bytes following <stringdata#>.

Text in dictionary entries is encoded in the dictionary table. A dictionary entry with a given address (_addr_) appears in the dictionary at __addr__+2 (since the first two bytes in the dictionary table are reserved for the number of entries) as:

<1 byte> ...encoded dictionary entry...

where the maximum allowable length of a dictionary entry is 255 characters.

Text written to the text bank is encoded at a given address in the text bank as:

<2 bytes> ...encoded text...

where the length of the encoded text is given by the first two bytes. (Note that an address in the text bank requires 3 bytes in the game code, however, since the length of the text bank can exceed 64K.)

== THE OBJECT TABLE


=== Objects



The object table begins with two bytes giving the total number of objects. The objects then follow in sequential order. Each object requires 24 bytes:footnote:[Pre-v2.1 objects had only 32 possible attributes, and the object size was only 12 bytes, with only 4 bytes given to the attribute array.]

*Bytes*

0 - 15 Attributes (128 bits in total, 1 bit/attribute)

16 - 17 Parent

18 - 19 Sibling

20 - 21 Child

22 - 23 Property table position

The offset of any given object _n_ from the start of the object table can therefore be found using:

offset = _n_ * 24 + 2

If a parent has no parent, sibling, and/or child, the appropriate two-byte word is set to $0000.

The property table position represents the offset of the beginning of the given object's property data from the start of the property table, as described below.

=== Attributes



The 16 bytes of the attribute array contain 8 bits each, giving a total of 128 possible attributes.footnote:[In v2.1 and later; there were only 32 attributes in earlier versions] Essentially, if the bits are thought of sequentially in that the first byte represents attributes 0 to 7, the second byte represents attributes 8 to 15, the third 16 to 23, and the fourth and final byte 24 to 31.

== THE PROPERTY TABLE



The property table begins with two bytes giving the total number of properties. This is followed by a list of default property values, each of one 16-bit (2 byte) word each. After this, the properties themselves begin, starting with object 0.

The property values are entered sequentially, with no explicit identification of what object a particular value belongs to. It is the object's object-table entry that gives the location of a given object's property data in the property table.

Each property requires at least 2 bytes:

*Byte*

0 Property number

1 Number of data words

2 - Data in 16-bit word form (2 bytes each)

Property routines are given a "`length`" of 255 ($FF), which indicates that one word of data follows, representing the (indexed) address of the routine.

At the end of each object in the property table comes the property number 255 ($FF)--not to be confused with the "`length`" 255, which denotes a routine address. "`Property`" number 255 is an exception to the two-byte minimum; it does not have any attached length byte or data words. Each object has a place in the object table, even if it has no properties per se. A propertyless object simply has the value 255 at its position in the property table.

(Property data being written for an .HLB linkable file is slightly altered. For example, property routines are marked by $FE instead of $FF. See _XIII.b_ _The Linker_.)

=== Before, After, and Other Complex Properties



Consider the following complex property for an unspecified object:

after

\{

object DoGet

\{

"You pick up the object."

}

object

\{

"You can't do that with the object."

}

}

(A simple explanation of the above is that <object>.after is called following a call to a verbroutine with which <object> was involved. If <object> was the object of the verbroutine (i.e., the object global), and the verbroutine global was DoGet, the first block runs. The second block will run if no previous block has run. For a full description of complex properties, see the Hugo Manual.)

First of all, the entry in the property table for <object>.after will point to the first line of code in the property routine. Arbitrarily, let's assume this is $000044: the earliest possible code address following a blank grammar table.

000040: FF 00 00 00 45 00 48 1A 00 25 15 00 47 00 00 00

000050: 0D 00 00 00 45 00 25 18 00 47 00 16 00 0D 00 00

000060: 0D 21 29

That can be compared to the original source code as:

000044: 45 00 48 1A 00

The initial `object DoGet` block header, assuming that the engine-defined global object is global variable number 0, and that the address of DoGet is $000068 (represented as an indexed address as $001A).

000049: 25 15 00

Following the jump token ($25) is the indexed address to jump to if `object DoGet` isn't matched. In this case, it is $0015, which translates to the absolute address $000054 (i.e., the address of the next header).

00004C: 47 00 00 00

The <textdata#> label is followed by three bytes giving the address in the text bank of the printed string "`You pick up the object.`"

000050: 0D 00 00 00

$0D signals the end of this block of executable code, followed by zeroes padding to the next address boundary.

000054: 45 00

This block header is simply `object`.

000056: 25 18 00

As above, following the jump token ($25) is the indexed address to jump to if the block header isn't matched. In this case, it is $0018, which translates to $000060 (i.e., the closing $0D of the after routine).

000059: 47 00 19 00 0D 00 00

The second line of text is printed here, followed by $0D to signal the end of this block of code and zero-padding to the next address boundary.

000060: 0D 21 29 4C

A $0D signals the end of the after routine. Property routines are followed by an automatic $21, $29, and $4C (i.e., `return true`).

== THE EVENT TABLE



The event table begins with two bytes giving the total number of events. Each event requires 2 bytes:

*Bytes*

0 - 1 Associated object (0 for a global event)

2 - 3 Address of event routine

== THE DICTIONARY AND SPECIAL WORDS


=== Dictionary



The dictionary begins with two bytes giving the total number of entries. Each dictionary entry is composed of 1 or more bytes:

*Byte*

0 Length of entry (number of characters)

1 - Entry as an encrypted string

=== Special Words



The special words table begins with two bytes giving the total number of entries. Each entry requires 5 bytes:

*Byte*

0 Type (0 = synonym, 1 = removal, 2 = compound,

3 = user-defined punctuation)

1 - 2 First dictionary address

3 - 4 Second address (for synonyms and compounds)

== RESOURCEFILES



A resourcefile is used to store multiple images, sounds, music tracks, etc. in one manageable file format. The format of a Hugo resourcefile is fairly straightforward.

Every resourcefile starts with a header of 6 bytes:

*00* `r` *[Note: old 24-bit resourcefiles used `R`]*

*01* Version number (i.e., 31 for version 3.1)

*02 - 03* Number of resources

*04 - 05* Length of index, in bytes

Following the header is the index itself. Each resource entry in the index looks like:

*00* Length of entry name (i.e., _n_ bytes)

*01 - n* Entry name

*4 bytes* Offset in resourcefile from end of index

*4 bytes* Length of resource, in bytes

[NOTE]
================================================================================
Older resourcefiles (designated by `R` in the header) had a limit of 17 MB on resourcefile size (or of any contained resource) and used the following for offset and length:
================================================================================



*3 bytes* Offset in resourcefile from end of index

*3 bytes* Length of resource, in bytes

*These are still supported by the Hugo Engine, but the compiler now writes 32-bit resourcefiles.*

Resources are then appended sequentially immediately following the index.

== THE HUGO COMPILER AND HOW IT WORKS



For reference, here is a simplified map of the compiler's function calls, along with the source files in which they are located. The leftmost functions are all called from main() in *hc.c*:

+----------------+

| ParseCommand() | - Parse command line, including filenames,

| hcmisc.c | switches, and other settings

+----------------+

|

+----------------+

| OpenFiles() | - Open initial source file, objectfile,

| hcfile.c | listing, and temporary files

+----------------+

|

+----------------+ +----------------------------------+

| Pass1() | | GetLine() - hcfile.c |

| hcpass.c |--| |

| | | CompilerDirective() - hccomp.c | [1.1]

| (Definitions) | | CompilerMem() - hccomp.c |

+----------------+ | AddDirectory() - hcmisc.c |

| | |

| | Def...() - hcdef.c | [1.2]

| | |

| | PrinttoAll() - hcmisc.c |

| | |

| | (LinkerPass1() - hclink.c) | [1.3]

| +----------------------------------+

|

|

+----------------+ +----------------------------+

| Pass2() | | GetWords() - hcfile.c |

| hcpass.c |--| |

| | | Build...() - hcbuild.c | [2.1]

| (Build) | | |

+----------------+ | (LinkerPass2() - hclink.c) | [2.2]

| +----------------------------+

| |

| |

+----------------+ +--------------------------+

| Pass3() | | BuildCode() - hcbuild.c | [2.3]

| hcpass.c |--+ +--------------------------+

| | | |

| (Resolve/Link) | | +-----------------------+

+----------------+ | | Code...() - hccode.c | [2.4]

| | Codeline() - hccode.c |

| +-----------------------+

| | [2.5]

| \+------------------------+

+--------------| Write...() - hcfile.c |

/| WriteCode() - hcfile.c |

+------------------------+

In *Pass 1*, the initial source file and any included files are read into one contiguous temporary file (called allfile in the source). Any compiler directives (i.e., lines beginning with `#`, `$` or `@`) are processed here [1.1], as are definitions of objects, attributes, properties, global variables, constants, and routines [1.2]. Once a line of source has been parsed and split into discrete words, it is written to allfile using PrinttoAll().

*Pass 2* is where the bulk of compilation takes place. Lines of pre-parsed source are read from allfile. After Pass 1, all symbols (except local variables) are known. Individual constructs such as verbs, objects, routines, and events are processed via Build...() functions (i.e., BuildVerb(), BuildObject(), etc.) [2.1].

At any point in Pass2(), the tokenized line currently being processed is held in the global word[] array, with the number of tokens in the current line in words.

Sections of executable code, such as routines, events, or property routines, are generated by calling BuildCode() [2.3], which in turn calls appropriate Code...() functions as necessary (i.e., CodeDo(), CodeIf(), CodeWhile(), etc.), or simply CodeLine() for any line that doesn't require special treatment [2.4]. Compiled byte-code is emitted to the objectfile via WriteCode() [2.5].

(In a departure from the normal order of defining symbols, synonyms, compounds words, removals, and user-defined punctuation are defined in Pass2(). Local variables are defined in BuildCode().)

By *Pass 3*, all executable code has been written to the objectfile, structures exist in memory representing to-be-constructed tables, and the text bank (long sections of printed text) exists in a temporary file. First, ResolveAddr() (from *hcmisc.c*) patches all references that were unknown at the time they were compiled. Pass3() then writes the object table, the property table, the event table, the array table, synonyms/removals/compounds/user-defined punctuation, the dictionary, and the text bank.

If a debuggable executable (called an .HDX file) is being generated, the last thing Pass3() does is to write the symbolic names of all objects, properties, attributes, aliases, globals, routines, events, and arrays to the end of the file.

=== Compile-Time Symbol Data



Here are the various structures, arrays, and variables used by

the compiler to keep track of symbols at compile-time:

*Objects:*

objctr total number of objects

object[n] symbolic name of object _n_

object_hash[n] hash value of symbol name

objattr[n][s] attribute set _s_ (32 attributes/set)

oprop[n] location in propdata[] array

objpropaddr[n] location in property table

parent[n] physical parent

sibling[n] physical sibling

child[n] physical child

oreplace[n] number of times replaced using the

replace directive

*Attributes:*

attrctr total number of attributes

attribute[n] symbolic name of attribute _n_

attribute_hash[n] hash value of symbol name

*Properties:*

propctr total number of properties

property[n] symbolic name of property _n_

property_hash[n] hash value of symbol name

propset[p] true if property _p_ has been defined

for current object

propadd[p] ADDITIVE_FLAG bit is true if

property _p_ is additive;

COMPLEX_FLAG bit is true if property

_p_ is a complex property

propdata[a][b] array of all property data

propheap size of property table

*Labels:*

labelctr total number of labels

label[n] symbolic name of label _n_

label_hash[n] hash value of symbol name

laddr[n] indexed address of label

*Routines:*

routinectr total number of routines

routine[n] symbolic name of routine _n_

routine_hash[n] hash value of symbol name

raddr[n] indexed address of routine

rreplace[n] number of times replaced using the

replace directive

*Events (although not really symbols):*

eventctr total number of events

eventin[n] object to which event _n_ is attached

eventaddr[n] indexed address of event code

*Aliases:*

aliasctr total number of aliases

alias[n] symbolic name of alias _n_

alias_hash[n] hash value of symbol name

aliasof[n] attribute or property aliased

(either the attribute number, or

the property number plus

MAXATTRIBUTES)

*Global variables:*

globalctr total number of global variables

global[n] symbolic name of global _n_

global_hash[n] hash value of symbol name

globaldef[n] initial value of global at startup

*Local variables:*

localctr total number of locals defined in the

current code block

local[n] symbolic name of local _n_

local_hash[n] hash value of symbol name

unused[n] true until local _n_ is used

*Constants:*

constctr total number of constants

constant[n] symbolic name of constant _n_

constant_hash[n] hash value of symbol name

constantval[n] defined value of constant

*Array:*

arrayctr total number of arrays

array[n] symbolic name of array _n_

array_hash[n] hash value of symbol name

arrayaddr[n] location in array table

arraylen[n] length of array _n_

arraysize current size of array table

*Dictionary:*

dictcount total number of dictionary entries

dicttable current size of dictionary

lexentry[n] dictionary entry _n_

lexaddr[n] location of entry n in dictionary

table

lexnext[n] location of word following n in the

lexentry[] array

lexstart[c] location of first word beginning with

character _c_ in lexentry[]

lexlast[c] location of last word beginning with

character _c_ in lexentry[]

*Special words:*

syncount total number of synonyms, compounds,

removals, and user-defined

punctuation

syndata[n] synstruct structure of _n_

The use of ..._hash[n] is a rough form of hash-table coding. The compiler, in FindHash() in *hcdef.c*, produces an _almost_ unique value for a given symbol based on the characters in it. Only if ..._hash[n] matches an expected value does a more expensive strcmp() string comparison have to be performed to validate the "`match`" (or reject it).

=== The Linker



The compiler has to be able to both create a linkable file (called an .HLB file, as it is usually a precompiled version of the library) and read it back when a #link directive is encountered.

In the first case, the compiler writes an .HLB file whenever the -h switch is set at invocation. In order to do that, it does the following things:

[arabic]
. Property routines, normally marked by a "`length`" of 255, are changed to a "`length`" of 254.
. All addresses are appended to the end of the file instead of being resolved in Pass3(). (Labels, being local and therefore not visible outside the .HLB file, are an exception; they are resolved as usual.)
. Additional data (such as symbolic names) of objects and properties are written in Pass3(). Immediately following the object table, the compiler, in Pass3(), writes all the relevant data for attributes, aliases, globals, constants, routines.
. The value `$$` is written into the ID string in the header.

Reading back (i.e., linking) an .HLB file is done in two steps: LinkerPass1() [1.3], called from Pass1(), and LinkerPass2()[2.2], called from Pass2(). (The linker routines are found in the source file *hclink.c*.)

LinkerPass1() simply skims the .HLB file for symbols and defines them accordingly, along with any relevant data. It also reads the .HLB file's text bank and writes it to the current file's temporary file containing the current text bank. Note that since linking must be done before any other definitions, there is no need to calculate offsets here for things like object numbers, addresses in the text bank, etc.

LinkerPass2() is responsible for reading the actual executable code. It does this mainly with a simple read/write (in blocks of 16K or smaller). It then reads the resolve table appended to the end of the .HLB file and writes it to the current resolve table so that Pass3() can properly resolve the offset code addresses at the end of compilation. (Since the actual start of executable code will vary depending on the length of the grammar table, it is not known at the .HLB file's compile-time what a given address may ultimately be. It is only known that, for example, routine _R_ is called from position _P_ in the source. Both _R_ and _P_ must be adjusted for the offset.)

In Pass3(), ResolveAddr() is now able to resolve addresses from the linked file. Additionally, those properties with a "`length`" of 254 are adjusted so that their values--which are really addresses of property routines--are adjusted as per the offset; the "`length`" of these properties is then written as 255.

== THE HUGO ENGINE AND HOW IT WORKS



Here is a simple map of the main engine loop and the associated functions:

................................................................................
+-------------+ +----------------------------+

| RunGame() |----| RunRoutine("init" routine) |

| herun.c | | herun.c |

+-------------+ +----------------------------+

/|\ \|/

| |

| | \+----------------------------+

| +----| RunRoutine("main" routine) | MAIN EXECUTION

| | /| herun.c | LOOP [1.1]

| | +----------------------------+

| | |

| | \ |

| +-------Player input [1.2]

| | / |

| | \|/

| | +----------------+

| | | Parse() | [2.1]

| | | heparse.c |

| | +----------------+

/|\ /|\ |

| | +----------------+ +---------------------------+

| | | MatchCommand() |--| MatchWord() - heparse.c |

| | | heparse.c | | MatchObject() - heparse.c |

| | +----------------+ +---------------------------+

| | | [2.2] [2.3]

| If input |

| is not-------+

| valid |

| |

| If input

| is valid

| |

| \|/

| +-------------------------+

| | RunRoutine(performaddr) | [3.1]

| | herun.c |

| +-------------------------+

|/ | .

+-----------------+ .

\ .

.

.

.

+-----------------------+

| Expression evaluator: | [4.1]

| heexpr.c |

| |

| SetupExpr() |

| | |

| GetValue()--GetVal() |

| | |

| EvalExpr() |

+-----------------------+
................................................................................

The functions in *herun.c* comprise most of the core game loop and calling points. RunGame() manages the game loop itself [1.1], which can be thought of as being:

*Main routine  Player input  Parsing  Action (if valid)*

*Player input* [1.2] is the point at which the engine requests a new input line (usually from the keyboard, but possibly from another source such as a file during command playback).

The *Parsing* section [2.1] refers to the in-engine breakdown and analysis of the input line. The input line is matched against the grammar table in MatchCommand() [2.2]--using MatchWord() and MatchObject() [2.3] to identify either individual words as specified in the grammar, or groups of words that may represent an object name.

If a match is made, the appropriate globals (object, xobject, verbroutine) are set, and Perform() is called [3.1] (or, if Perform() has not been defined, the built-in substitute). (Note that if the command is directed to an object--i.e., another character--SpeakTo() is called instead of Perform().)

RunRoutine() is the method by which any function calls are executed. At any point in RunRoutine() (or in functions called by it), the value mem[codeptr] is the byte value (i.e., the token number) of the current instruction. The value of codeptr advances as execution progresses.

Whenever it is necessary for the engine to evaluate an expression, the expression evaluator subsystem in *heexpr.c* is invoked [4.1]. Here, the eval[] array is initialized with the expression to be evaluated by calling SetupExpr() (which will in turn call GetValue() to sequentially retrieve the elements of the expression). The expression currently in eval[] is solved by calling EvalExpr().

=== Runtime Symbol Data



*Code execution:*

mem[] loaded .HEX file image

defseg current memory segment

codeseg code segment (i.e., 0)

codeptr current code position

stack_depth current calling depth

*Display:*

pbuffer[] print buffer for line-wrapping

currentpos current position (pixel or character)

currentline current row (line)

full counter for PromptMore() page-ending

fcolor, bgcolor, colors for foreground, background,

icolor, input, and default background

default_bgcolor

currentfont current font bitmask

textto if non-zero, text is printed to this

array

SCREENWIDTH, maximum possible screen dimensions

SCREENHEIGHT

inwindow true if in a window

physical_windowwidth, "`physical`" window dimensions,

physical_windowheight, in pixels or characters

physical_windowleft,

physical_windowtop,

physical_windowright,

physical_windowbottom

charwidth, lineheight, for font output management

FIXEDCHARWIDTH,

FIXEDLINEHEIGHT,

current_text_x,

current_text_y

*Parsing:*

words number of parsed words in input

word[] breakdown of input into words

wd[] breakdown of input into dictionary

entries

*Arguments and expressions:*

var[] global and local variables

passlocal[] locals passed to a routine

arguments_passed number of arguments passed

ret return value (from a routine)

incdec amount a value is being incremented

or decremented

*Undo management:*

undostack[] for saving undo information

undoptr number of operations undoable

undoturn number of operations for this turn

undoinvalid when undo is invalid

undorecord true when recording undo info

=== Non-Portable Functionality



The Hugo Engine requires a number of non-portable functions which provide the interface layer between the engine and the operating system on which it is running. These functions are:

hugo_blockalloc Large-block malloc()

hugo_blockfree Large-block free()

hugo_splitpath For splitting/combining filename/path

hugo_makepath elements as per OS naming conventions

hugo_getfilename Asks the user for a filename

hugo_overwrite Verifies overwrite of a filename

hugo_closefiles fcloseall() or equivalent

hugo_getkey getch() or equivalent

hugo_getline Keyboard line input

hugo_waitforkey Cycles while waiting for a keypress

hugo_iskeywaiting Reports if a keypress is waiting

hugo_timewait Waits for 1/_n_ seconds

hugo_init_screen Performs necessary display setup

hugo_hasgraphics Returns graphics availability

hugo_setgametitle Sets title of window/screen

hugo_cleanup_screen Performs necessary screen cleanup

hugo_clearfullscreen Clears entire display area

hugo_clearwindow Clears currently defined window

hugo_settextmode Performs necessary text setup

hugo_settextwindow Defines window in display area

hugo_settextpos Sets cursor/text-output position

hugo_scrollwindowup Scrolls currently defined window

hugo_font Sets font for text output

hugo_settextcolor Sets foreground color for text

hugo_setbackcolor Sets background color for text

hugo_color Returns a valid color reference

hugo_print Outputs formatted text

hugo_charwidth Returns width of a given character

hugo_textwidth Returns width of a given string

hugo_strlen strlen() for embedded codes

hugo_specialchar Translation for special characters

hugo_hasvideo Returns video availabilityfootnote:[v3.0 and later]

For elaboration of the intent and implementation of these functions, see *heblank.c* in the standard source distribution (*hugov31_source.tar.gz*), or one of the implementations such as *hemsvc.c* (in *hugov31_win32_source.zip*, the Windows source package), *hegcc.c* (in *hugov31_unix_source.tar.gz*, the gcc/Unix package), etc.

=== Savefile Format



Hugo saves the game state by (among other things) saving the dynamic memory from start of the object table to the start of the text bank (i.e., including objects, properties, array data, and the dictionary). It does this, however, in a format that only notes if the data has changed from its initial state.

The structure of a Hugo savefile looks like this:

*0000 - 0001* ID (assigned by compiler at compile-time)

*0002 - 0009* Serial number

*000A - 0209* All variables (global and local, 256*2 bytes)

*020A -* Object table to text bank (see below)

*n bytes* Undo data (where n = MAXUNDO*5*2 bytes)

*2 bytes* undoptr

*2 bytes* undoturn

*1 byte* undoinvalid

*1 byte* undorecord

In saving from the object table up to the start of the text bank, the engine performs a comparison of the original gamefile against in-memory dynamic data (which may have changed).

If a given byte _n_ in a savefile is non-zero, it represents that the next _n_ sequential bytes are identical between the gamefile and the saved data. If _n_ is 0, the byte __n__+1 gives the value from the memory image. (Although it takes 2 bytes to represent a single changed byte, the position within both the gamefile and the memory image only increases by 1.)

The practical implementation of the Hugo savefile format is found in RunSave() and RunRestore() in *herun.c*.

== DARK SECRETS OF THE HUGO DEBUGGER



The Hugo Debugger is basically a modified build of the Hugo Engine; the two share the same core code for program execution, but the debugger wraps it in a calling framework that allows the user (or the debugger itself) to control--i.e., start, stop, or step through--execution.

The key difference with the debugger build of the engine is in RunRoutine(), which in the debugger looks more like this:

...

|

|

+--------------+ +------------+

| RunRoutine() |---->| Debugger() | (if debugger_interrupt

| herun.c | | hd.c | is non-false)

+--------------+ +------------+

|

|

...

The debugger build contains a global flag called debugger_interrupt; if this flag is non-false, RunRoutine() is interrupted before executing the next instruction.

The Debugger() function is responsible for switching to and updating the debugger display. Debugger() is also the hub for any debugger functions initiated by the user, such as setting breakpoints, setting watch expressions, changing values, moving objects, etc.

The debugger controls program execution by returning from Debugger()to RunRoutine(). If debugger_interrupt is true, only the current instruction will execute, then control will pass back to Debugger() (i.e., stepping). In order to resume free execution, Debugger() returns with debugger_interrupt set to false.

A number of other variables in the debugger influence program execution in addition to debugger_interrupt:

debugger_run true when engine is running freely

debugger_collapsing true when collapsing the call

debugger_step_over true if stepping over (i.e., same-

level stepping)

debugger_skip true if skipping next instruction

debugger_finish true if finishing current routine

debugger_step_back true if stepping backward

step_nest for stepping over nested calls (i.e.,

with debugger_step_over)

=== Debugger Expression Evaluation



The debugger must evaluate expressions in several contexts, including when solving watch expressions and when changing an existing value. (In-debugger expression management is contained primarily in *hdval.c*.)

In order to do this, the debugger includes a minimal version of the compiler's expression parser. It parses a user-supplied expression in the function ParseExpression(). What ParseExpression() does is to essentially compile that expression, storing the result in the debug workspace in the array table. (Remember that the address of the debug workspace--256 bytes after any user-defined array storage--is found in the header in .HDX files.)

After writing the expression, the debugger can then set codeptr to the start of the debug workspace, then call the engine's SetupExpr() and EvalExpr() functions as it would to evaluate any other expression.

=== The .HDX File Format



The .HDX file format for Hugo debuggable executables, as well as having some additional information in the header (see _II.b_ _The Header_) and a 256 byte workspace reserved at the end of the array table, appends symbolic debugging data as follows:

*Object names* For each object: 1 byte giving the

length, followed by the name as a

string

*# of properties* 2 bytes

*Property names* For each property: 1 byte (length),

then the name

*# of attributes* 2 bytes

*Attribute names* For each attribute: 1 byte

(length), then the name

*# of aliases* 2 bytes

*Alias names* For each alias: 1 byte (length),

then the name, then two bytes for

the association

*# of routines* 2 bytes

*Routine names* For each routine: 1 byte (length),

then the name

*# of events* 2 bytes

*Event data* 4 bytes for each--2 bytes for the

parent; 2 bytes for the address

*# of arrays* 2 bytes

*Array data* For each array: 1 byte for the name

length, followed by the name,

followed by 2 bytes for the address

(Note that it isn't necessary to store the total number of objects, since that is already available at the start of the normal object table.)

== CODE PATTERNS

What follows is a detailed breakdown of how the set of valid tokens in Hugo is encoded and read within compiled code.

Tokens simply marked *TOKEN* are coded just as the byte value of the token in question; no other formatting or necessary token/value is required to follow. These are typically used for delimitation, signaling the end of a structure or structure component, etc.

*STATEMENTS* are those tokens that are read by the engine as some sort of operation--typically, these are "`start of line`" tokens, with some exceptions.

*VALUES* return an integer value to the engine within the context of an expression. See _III.b_ _Data Types_, which describes all the valid types of values.

*INTERNAL* tokens never appear in source code. These are added by the compiler for use by the engine.

A "`code block`" is any executable statement or statements followed by a terminating $0D (`}`).

Constructions may include _expressions_ or _values_; the difference between the two is that values are expected to be discrete data types. Note also that GetVal() in *heexpr.c* allows a solvable expression bracketed by $01 (`(`) and $02 (`)`) to be treated as a discrete value.

Source references point to places in the Hugo C source code that may help to clarify how a particular construction is coded/interpreted. While not specifically mentioned, the compiling of many tokens is localized in CodeLine() in *hccode.c*, and the execution of many simple statements is localized in RunRoutine() in *herun.c*. The reading of values from data types or expressions begins with GetValue() in *heexpr.c*, with the basic identification of values in GetVal().

*01 ( TOKEN*

*02 ) TOKEN*

*03 . TOKEN*

*04 : reserved (not coded)*

*05 = TOKEN*

*06 - TOKEN*

*07 + TOKEN*

*08 * TOKEN*

*09 / TOKEN*

*0A | TOKEN*

*0B ; TOKEN*

*0C \{ TOKEN*

*0D } TOKEN*

(Signifies the end of a code block)

*0E [ TOKEN*

*0F ] TOKEN*

*10 # TOKEN*

*11 ~ TOKEN*

*12 >= TOKEN*

*13 <= TOKEN*

*14 ~= TOKEN*

*15 & TOKEN*

*16 > TOKEN*

*17 < TOKEN*

18 if STATEMENT

18 <skip distance> <expression> 4C

<conditional block>

<next statement>

*As in:* if <expression>

\{...}

Where the two bytes of <skip distance> are the absolute distance--in low-byte/high-byte order--from the first byte of the pair to the next line of code that will execute if <expression> evaluates to false, i.e., the distance to <next statement>. If <expression> evaluates to a non-false value, <conditional block> is run. Note that $4C indicates end-of-line.

<expression> is simply a tokenized representation of the expression as it appears in the source line.

*Source: hccode.c* – CodeIf()

*herun.c* – RunIf()

*19 , TOKEN*

1A else STATEMENT

1A <skip distance>

<conditional block>

<next statement>

*As in:* else

\{...}

Where <conditional block> runs only if no immediately preceding if or elseif condition has been met. If a previous condition has been met, control passes ahead to <next statment>, i.e., forward the number of bytes given by the two bytes of <skip distance>.

*Source:* *hccode.c* – CodeLine()

*herun.c* – RunIf()

1B elseif STATEMENT

1B <skip distance> <expression> 4C

<conditional block>

<next statement>

*As in:* elseif <expression>

\{...}

See if.

*Source:* *hccode.c* – CodeIf()

*herun.c* – RunIf()

1C while STATEMENT

:<starting point>

1C <skip distance> <expression> 4C

<conditional block>

25 <starting point>

<next statement>

*As in:* while <expression>

\{...}

As long as <expression> evaluates to a non-false value, <conditional block> is run. Note the implicit jump ($25) coded by the compiler to maintain the loop--<starting point> is only an address; only the two-byte address following $25 is written as a jump-back point. See if.

Note that because the <starting point> is written as a two-byte indexed address, it must begin on an address boundary, padded with empty ($00) values, if necessary.

*Source:* *hccode.c* – CodeWhile()

*herun.c* – RunIf()

1D do STATEMENT

1D <skip distance>

:<starting point>

<block>

1C <two bytes> <expression> 4C

<next statement>

*As in:* do

\{...}

while <expression>

If, after <block> executes, <expression> evaluates to a non-false value, the engine returns to <starting point> (which must begin on an address boundary). The two bytes following while ($1C) match the syntax of the normal while loop, but are undefined for this usage. Instead, the distance to the next statement is given after the do token ($1D) in the two bytes of <skip distance>.

Source: *hccode.c* – CodeDo()

*herun.c* – RunDo()

1E select STATEMENT

1E

When encountered by the engine, resets the conditional-statement evaluator, i.e., so that the next case conditional is treated as an if instead of an elseif. Note that the variable that follows select in a line of source code is not coded here (but it is needed by the compiler to construct subsequent case statements).

See case.

*Source:* *hccode.c* – CodeSelect()

*herun.c* – RunIf()

1F case STATEMENT

Treated identically by the engine to elseif once a select token ($1E) has reset the conditional-statement evaluator to no previous matches.

In other words, what the compiler does is take:

select <expression>

case <test1>

<first conditional block>

case <test2>

<second conditional block>

...

case else

<default conditional block>

and restructure it into:

1F <skip distance> <expression> 05 <test1> 4C

<first conditional block>

1F <skip distance> <expression> 05 <test2> 4C

<second conditional block>

1A <skip distance>

<default conditional block>

Note that $1A is the else token, $05 is the `=` token, and that the two bytes of <skip distance> give the distance to the next case.

*Source:* *hccode.c* – CodeSelect()

*herun.c* – RunIf()

20 for STATEMENT

<assignment>

:<starting point>

20 <skip distance> <expression> 4C

<conditional block>

<modifying expression>

25 <starting point>

<next statement>

*As in:* for (<assign>; <expr>; <modifying>)

\{...}

The <assignment>, if given in the source code, is coded as a regular executable assignment of some data type. Again, nothing is explicitly coded at <starting point>--it is simply a reference point for the jump ($25) to return to. The for ($20) line operates as a regular conditional test (see if). The <modifying expression> is appended after the conditional block is coded. This, like the <assignment> is simply a regular executable assignment.

*Source:* *hccode.c* – CodeFor()

*herun.c* – RunIf()

21 return STATEMENT

21 <expression> 4C

*As in:* return <expression>

Where <expression> is optional, so that a standalone return order can be coded as:

21 4C

22 break STATEMENT

22

*23 and TOKEN*

*24 or TOKEN*

25 jump STATEMENT

25 <address>

*As in:* jump <label>

Where <address> is two bytes giving the indexed address of the next statement to be executed. (The <label> is coded as <address>.)

26 run STATEMENT

26 <value> 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C).]

Where <value> is simply read and forgotten, as in running an object.property property routine and throwing away the value.

27 is TOKEN

As in: <object> is <attribute> (statement form)

<object> is <attribute> (value form).

*28 not TOKEN*

29 true VALUE

29

Hard-coded Boolean constant meaning 1.

2A false VALUE

2A

Hard-coded Boolean constant meaning 0.

*2B local reserved (not coded)*

2C verb STATEMENT

2C <n> <dict_1> <dict_2>...<dict_n>

Occurs in the grammar table and explicitly denotes the beginning of a new verb, where the single byte <n> gives the number of dictionary words coded immediately following representing synonyms for this verb.

2D xverb STATEMENT

2D <n> <dict_1> <dict_2>...<dict_n>

Coded and handled identically to verb, except that it is flagged differently so the engine knows it is a "`non-action`".

*2E held GRAMMAR TOKEN*

*2F multi GRAMMAR TOKEN*

*30 multiheld GRAMMAR TOKEN*

31 newline PRINT TOKEN

Signals a print statement to issue a newline _only_ if one is needed.

*32 anything GRAMMAR TOKEN*

33 print STATEMENT

33 <print data> 4C

33 <print data> 0B <print data> ... 4C

Where <print data> is one of the following:

stringdata#

any value, treated as a dictionary entry

parse$

serial$

newline

capital

number

hex

Multiple <print data> sequences are separated by a semicolon (`;`) token ($0B).

*Source:* *herun.c* – RunPrint()

34 number GRAMMAR TOKEN or PRINT TOKEN

In a print statement, signals that the following value should be printed as a number, not as the corresponding dictionary entry.

In a grammar line, represents any integer number.

35 capital PRINT TOKEN

Signals that the following dictionary entry should have its first letter capitalized.

36 text STATEMENT

36 3B <value> 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C).]

*As in:* text to n

Where <value> is either an address in the array table, or constant 0 (to restore text output to the standard display).

37 graphics STATEMENT

(Not implemented.)

38 color STATEMENT

38 <value> 4C

38 <value> 19 <value> 4C

38 <value> 19 <value> 19 <value> 4C

*As in:* color foreground

color foreground, background

color foreground, background, inputcolor

Where <value> is a Hugo color value from 0 to 17 giving the foreground text color. If a second value is given, separated by a comma ($19), it represents the background color. If a third value is given, separated by a comma ($19), it represents the input color.

39 remove STATEMENT

39 <value> 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C).]

*As in:* remove <object>

*Source:* *herun.c* – RunMove()

3A move STATEMENT

3A <value> 3B <value> 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C).]

*As in:* move <object1> to <object2>

*Source:* *herun.c* – RunMove()

3B to TOKEN

Followed by a value, as in:

3B <value>

Typically found in `print to n`, `text to n`, etc., in which case the line will finish with eol#:

...3B <value> 4C

3C parent VALUE

3C 01 <expression> 02

*As in:* parent(...)

Returns the parent object of the object resulting from <expression>.

(Alternate usage is as a grammar token, coded simply as $3C with no following parenthetical expression.)

3D sibling VALUE

3D 01 <expression> 02

*As in:* sibling(...)

Returns the sibling of the object resulting from <expression>.

3E child VALUE

3E 01 <expression> 02

*As in:* child(...)

Returns the child object of the object resulting from <expression>.

3F youngest VALUE

3F 01 <expression> 02

*As in:* youngest(...)

Returns the youngest (most recently added) child object of the object resulting from <expression>.

40 eldest VALUE

40 01 <expression> 02

*As in:* eldest(...)

Iinterpreted identically to `child(...)`.

41 younger VALUE

41 01 <expression> 02

*As in:* younger(...)

Interpreted identically to `sibling(...)`.

42 elder VALUE

42 01 <expression> 02

*As in:* elder(...)

Returns the object number of the object more recently added to the parent of the object resulting from <expression>.

43 prop# INTERNAL VALUE

43 <property>

Where <property> is a single byte giving the property number.

44 attr# INTERNAL VALUE

44 <attribute>

Where <attribute> is a single byte giving the attribute number.

45 var# INTERNAL VALUE

45 <variable>

Where <variable> is a single byte giving the variable number. 0-239 are global variables, and 240-255 are local to this routine/event/etc.

46 dictentry# INTERNAL VALUE

46 <dictionary entry>

Where <dictionary entry> is two bytes (in low-byte/high-byte order) giving the address of the entry in the dictionary table.

47 text# INTERNAL STATEMENT

47 <text address>

Where <text address> is three bytes (in lowest-to-highest byte order) giving the address of the entry in the text bank.

48 routine# INTERNAL STATEMENT or VALUE

48 <routine address>

Where <routine address> is two bytes giving the indexed address of the specified routine.

49 debugdata# INTERNAL DATA

Is followed by data that is helpful to the engine at runtime--not visible in, for example, the debugger's code window.

E.g., local variable name:

49 45 <byte> <data>

Where <byte> is a single byte giving the number of following <data> bytes, which give the name of the next local variable as an ASCII string. Read by the debugger; ignored by the engine.

4A object# INTERNAL VALUE

4A <object number>

Where <object number> is two bytes giving the number of the specified object.

4B value# INTERNAL VALUE

4B <number>

Where <number> is two bytes giving the specified constant value.

4C eol# INTERNAL TOKEN

End-of-line marker.

4D system INTERNAL STATEMENT or VALUE

4D 01 <value> 02 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C).]

*As in:* system(<value>)

Calls the system-level function designated by <value>. (See _The Hugo Programming Manual_ for further elaboration on the system statement.)

Obsolete usage:footnote:[Not implemented post-v2.2.]

4D <value>

Where <value> is some Hugo data type giving the number of the system function to call.

*Source:* *herun.c* – RunSystem()

*4E notheld GRAMMAR TOKEN*

*4F multinotheld GRAMMAR TOKEN*

50 window STATEMENT

window n

50 <value> 4C

window left, top, right, bottom

50 <v1> 19 <v2> 19 <v3> 19 <v4> 4C

window

50 4C

window 0

50 4B 00 00 4C

Where <value> or <v__n__>, if present, gives a number of lines or screen coordinate. All instances of the window statement are followed by a code block except for `window 0`. (See _The Hugo Programming Manual_ for further elaboration on the window statement.)

(Prior to v2.4, the third syntax, i.e., `window` alone, complied as `50 4C` in v2.3 or simply `50` in early versions, followed by a code block, was the only usage. The result was a window beginning at the top of the screen, reaching down to the current cursor row at the termination of the block, and protected then from scrolling of the bottom/main window.)

*Source:* *herun.c* – RunWindow()

51 random VALUE

51 01 <expression> 02

*As in:* random(...)

Returns a random value between 1 and <expression>.

52 word VALUE

52 0E <expression> 0F

*As in:* word[...]

Returns the dictionary address of word[<expression>].

53 locate STATEMENT

53 <value> 4C

53 <value> 19 <value> 4C

*As in:* locate x

locate x, y

Where <value> is the column position to reposition the cursor to within the currently defined window. If a second value is given, it represents the new row position.

54 parse$ TOKEN

Read-only engine variable representing the engine parser's internal parse$ string.

*Source:* *herun.c* – RunPrint()

*hemisc.c* – Dict(), GetWord()

55 children VALUE

55 01 <expression> 02

*As in:* children(...)

Returns the number of children owned by the object resulting from <expression>.

56 in TOKEN

*As in:* for <object> in <parent>

or

if <object> [not] in <parent>

57 pause STATEMENT

57

Waits for a keypress. Stores the resulting key value in word[0].

58 runevents STATEMENT

58

Runs all events in scope.

59 arraydata# VALUE

array[<expression>] – element <expression> of array <array>

59 <array> 0E <value> 0F

array[]– length of array <array>

59 <array> 0E 0F

array – address of array <array>

59 <array>

Where <array> is two bytes giving the address of the array in the array table.

5A call STATEMENT or VALUE

5A <value> 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C) when used as a statement.]

*As in:* call <routine address>

Where <value> gives the indexed address of the routine to be called.

5B stringdata# PRINT TOKEN

5B <__n__> <char1> <char2> <char3> ... <char__n__>

Valid only in a print statement. <__n__> gives the number of characters contained in the print string.

*Source:* *herun.c* – RunPrint()

5C save VALUE

*As in:* x = save

Calls the engine's save-game procedure (which includes filename input); returns a true value on success, or false on failure.

*Source: herun.c* – RunSave()

5D restore VALUE

*As in:* x = restore

Calls the engine's restore-game procedure (which includes filename input); returns a true value on success, or false on failure.

*Source:* *herun.c* – RunRestore()

5E quit STATEMENT

5E

Terminates program execution and exits the engine.

5F input STATEMENT

5F

Prompts for user input, storing the resulting word(s) in the word[] array. Unknown (i.e., non-dictionary) words become 0, or `+""+`; the last unknown word is stored in parse$.

*Source: herun.c* – RunInput()

60 serial$ PRINT TOKEN

Read-only engine variable representing the compiler-determined serial number.

*Source:* *hemisc.c* – GetWord()

61 cls STATEMENT

61

Clears the currently defined text window.

62 scripton VALUE

*As in:* x = scripton

Calls the engine's begin-scripting procedure (which includes filename input); returns a true value on success, or false on failure.

*Source:* *herun.c* – RunScript()

63 scriptoff VALUE

*As in:* x = scriptoff

Calls the engine's end-scripting procedure; returns a true value on success, or false on failure.

*Source: herun.c* – RunScript()

64 restart VALUE

*As in:* x = restart

Attempts to reload the dynamic game data and restart the game loop; returns a true value on success or false on failure.

65 hex PRINT TOKEN

Signals that the following value should be printed as a hexadecimal number, not as the corresponding dictionary entry.

66 object GRAMMAR TOKEN

(Removed as a token after grammar table is compiled so that `object` can refer to the object global variable.)

67 xobject GRAMMAR TOKEN

(Removed as a token after grammar table is compiled so that `xobject` can refer to the xobject global variable.)

68 string VALUE

68 01 <expr1> 19 <expr2> 19 <expr3> 02

*As in:* x = string(a, "apple", 8)

Calls the engine string-writing function to write the dictionary entry <expr2> into the array table at the array address given by <expr1>, to a maximum of <expr3> characters. <expr1> is any data type or expression; <expr2> is either a value or the parse$ token ($54); <expr3> is optional, and if it is not given, the $02 token comes in place of the second $19.

*Source:* *herun.c* – RunString()

69 array VALUE

69 <value>

Forces <value> to be used as an address in the array table, so that `array <value>` can be used as arraydata#.

*Source:* *heexpr.c* – GetVal()

6A printchar STATEMENT

6A <value1> 19 <value2> 19 ... 4C

*As in:* printchar 'A', 'B',...

Outputs a single ASCII character value at the current screen position. Multiple values are separated by $19; the sequence is terminated by $4C.

6B undo VALUE

*As in:* x = undo

Attempts to restore all data changes made since the last typed input; returns a true value on success or false on failure.

*Source:* *hemisc.c* – SaveUndo(),Undo()

6C dict VALUE

6C 01 <expr1> 19 <expr2> 02

*As in:* x = dict(<array>, <len>)

Calls the engine dictionary-writing function to write the given string into the dictionary, to a maximum of <len> characters. If <expr1> is parse$ ($54), then the value of parse$ is used; otherwise <expr1> is an array address in the array table. If the string is already a dictionary entry, its location is returned. Otherwise, it is appended to the end of the table, and the new location is returned.

*Source:* *hemisc.c* – Dict()

6D recordon VALUE

*As in:* x = recordon

Calls the engine's begin-command-recording procedure (which includes filename input); returns a true value on success, or false on failure.

*Source:* *hemisc.c* – RecordCommands()

6E recordoff VALUE

*As in:* x = recordoff

Calls the engine's end-command-recording procedure; returns a true value on success, or false on failure.

*Source:* *hemisc.c* – RecordCommands()

6F writefile STATEMENT

6F <value> 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C).]

...file i/o code block...

*As in:* writefile <file>

\{...}

Opens the file named by the dictionary entry <value>, erasing it if it previously exists, and runs the following code block. Upon any error, jumps to the end of the file i/o code block and closes <file>.

*Source:* *hemisc.c* – FileIO()

70 readfile STATEMENT

70 <value> 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C).]

...file i/o code block...

*As in:* readfile <file>

\{...}

Opens the file named by the dictionary entry <value> and runs the following code block. Upon any error, jumps to the end of the file i/o code block and closes <file>.

71 writeval STATEMENT

71 <value> 19 <value> 19 ... 4Cfootnote:[Pre-v2.3 omitted the eol# marker ($4C).]

Valid only in a writefile block. Writes <value> as a 16-bit integer to the currently open file. Multiple values are separated by $19.

72 readval VALUE

*As in:* x = readval

Valid only in a readfile block. Reads a 16-bit integer from the currently open file.

73 playback VALUE

*As in:* x = playback

Calls the engines command-playback procedure (including filename input) and attempts to begin command playback from the requested file. If found, player input in RunGame() is overridden by commands in the file until end-of-file. Returns true on success, false on failure.

74 colour STATEMENT

Treated identically to $38: color.

75 picture STATEMENT

75 <value1> 19 <value2> 4C

75 <value1> 4C

Attempts to load and display a JPEG-format picture either as resource <value2> in resourcefile <value1>, or, if <value2> is not given, simply as filename <value1>. (All <values> are dictionary entries.) If there is an error, the system_status global variable is set.

*76 label# INTERNAL DATA*

77 sound STATEMENT

77 [79] <value1> 19 <value2> [19 <value3>] 4C

77 <value1> 4C

Attempts to load and play a WAV-format sample as resource <value2> in resourcefile <value1>. (<value1> and <value2> are dictionary entries.) If <value3> is given, the sample output volume is set to <value3> (as a percentage of normal output). If <value1> is 0, the current sound is stopped. If there is an error, the system_status global variable is set.

78 music STATEMENT

78 [79] <value1> 19 <value2> [19 <value3>] 4C

78 <value1> 4C

Attempts to load and play a music resourcefootnote:[Version 2.5 supports MOD, S3M, and XM-format music modules. Version 3.0 and later additionally support MIDI and MP3 files.] as resource <value2> in resourcefile <value1>. (<value1> and <value2> are dictionary entries.) If <value3> is given, the music output volume is set to <value3> (as a percentage of normal output). If <value1> is 0, the current music is stopped. If there is an error, the system_status global variable is set.

79 repeat TOKEN

Used by sound and music statements.

*INDEX*

.HDX file format, 264

.HEX file format, 225

abs (library routine), 202

accented characters, 62, 63, 95, 261

Acquire (library routine), 42, 43, 192

Activate (library routine), 100, 101, 105, 106, 204, 212

adjective (property, compiler-defined), 45, 48, 49, 51, 97, 113, 118, 135, 138, 140, 183

AFTER_PERIOD (library global variable), 180

aliases, 45, 118, 208, 252, 253, 255, 265

already_listed (library attribute), 40, 180

AND_WORD (library constant), 182

AnyVerb (library routine), 92, 192

ARE_WORD (library constant), 182

arguments of routines, 82, 158

Arnold, Julian, 3

array space, 69, 208

arrays, 20, 66, 68, 69, 70, 93, 102, 149, 159, 173, 208, 239, 252, 254, 265, 284

definition, 68

ASCII characters, 19, 62, 63, 151, 241, 280, 288

assignments, 24

AssignPronoun (library routine), 189, 190, 192

attachable objects, 142

attributes, 20, 39, 40, 41, 42, 45, 48, 49, 50, 51, 53, 117, 121, 122, 132, 149, 195, 198, 199, 208, 216, 242, 251, 252, 255, 264

aliases, 40

definition, 39

BANNER (library constant), 20, 93, 181

Baranov, Dmitry, 3

before and after routines, 88, 89, 91, 104, 124, 126, 129, 198, 246

BeOS, 3, 13, 219

BGCOLOR (library global variable), 93, 180

Bijster, Mark, 3

bitwise operators, 65

Blasius, Volker, 3

Blask, Jonathan, 3

BOLD_OFF (font style mask constant), 62, 93, 182

BOLD_ON (font style mask constant), 62, 93, 182

Bostock, Gerald, 3

Bowes, Cam, 3

Brown, Jason, 3

CalculateHolding (library routine), 94, 192, 193

CancelScript (library routine), 103, 205

cant_go (library property), 44, 185

capacity (library property), 42, 44, 46, 97, 132, 183, 192

Cardenas, Daniel, 3

CArt (library routine), 191, 211

Cebrian, Jose Luis, 3

CenterTitle (library routine), 193, 197

character class, 132

character scripts, 102, 103, 181, 205

routines, 94, 95, 102, 103, 104, 126, 205, 206, 211

CheckReach (library routine), 193

classes

definition, 48

clothing (library attribute), 39, 179

command-line, 7, 9, 13, 15, 16, 28, 213, 250

comments, 3, 25, 31, 32

multiple-line, 25

compiler

directives, 27, 31, 251

errors, 25, 32

invocation, 9, 13, 14, 28

limit settings, 12, 13, 16, 28, 30

precompiled headers, 6, 11, 28, 216, 217

compiler internal data structures, 252

compiling, 9, 13, 14, 28

component class, 136

compounds, 113

conditional compilation, 28, 209, 217

constants, 19, 20, 22, 23, 43, 52, 54, 55, 56, 59, 62, 65, 66, 68, 93, 94, 150, 155, 160, 162, 170, 175, 176, 182, 187, 195, 208, 251, 254, 255, 273, 275, 280

enumerating, 55

container (library attribute), 39, 40, 98, 110, 121, 136, 179, 183, 184

Contains (library routine), 105, 193

contains_desc (library property), 45, 97, 98, 185

counter (library global variable), 93, 94, 98, 105, 126, 181, 195, 196, 259

CThe (library routine), 129, 191, 192, 210

cursor_column (display object property), 45, 146, 147, 187

cursor_row (display object property), 45, 146, 187

CustomError (library routine), 121, 181, 190, 194

customerror_flag (library global variable), 181

d_to (library property), 44, 185

daemons (see also fuses), 100

DarkWarning (library routine), 194, 198

data types, 19, 21, 30, 31, 43, 52, 55, 57, 58, 59, 65, 157, 158, 228, 229, 230, 266, 272, 281, 287

Deactivate (library routine), 101, 105, 106, 204, 212

debugger, 2, 3, 5, 11, 213, 263

debugging, 10, 11, 16, 28, 33, 58, 118, 122, 123, 125, 210, 211, 213, 223, 227, 264

DEF_FOREGROUND (color constant), 60, 93, 182

DEF_SL_FOREGROUND (color constant), 60, 93, 182

DEFAULT_FONT (library global variable), 93, 180

DeleteWord (library routine), 194

desc_detail (library property), 45, 186

DESCFORM_F (printing format mask constant), 182

DescribePlace (library routine), 17, 94, 194

dictionary entries, 11, 12, 13, 55, 56, 70, 72, 160, 197, 214, 241, 254, 290, 291

dictionary table, 20, 72, 80, 112, 167, 209, 213, 226, 230, 233, 241, 279

direction class, 131

disambiguation, 122, 189, 210

display object, 34, 45, 146, 147, 151, 187

properties, 187

door class, 136, 137

door_to (library property), 44, 98, 137, 186

DOS, 3, 7, 9, 11, 61, 63, 79, 213

do-while loops, 75, 77, 161, 176

DOWN_ARROW (library constant), 182

Duchesne, Gilles, 3

Dyer, Jason, 3

e_to (library property), 44, 131, 185

endflag (global variable, compiler-defined), 127, 189

EndGame (junction routine), 54, 121, 128, 227

engine globals (compiler-defined), 180

engine internal data structures, 259

engine properties (compiler-defined), 183

ENTER_KEY (library constant), 182

enterable (library attribute), 39, 98, 179, 184, 229

ESCAPE_KEY (library constant), 182

event table, 247, 251

event_flag (library global variable), 104, 181

events, 247

global, 95, 247

exclude_from_all (library property), 44, 183

ExcludeFromAll (library routine), 189, 194

expressions, 24, 56, 65, 68, 74, 213, 215, 229, 260, 263, 264, 266

conditional, 77, 163

female (library attribute), 39, 120, 132, 179

FILE_CHECK (library constant), 150, 170, 183

files

reading, 149, 150, 170, 171, 177, 183, 229, 289, 290

writing, 149, 150, 170, 177, 178, 183, 229, 289, 290

FindLight (library routine), 20, 65, 68, 94, 195

FindObject (junction routine), 95, 118, 121, 122, 210, 227

Font (library routine), 62, 93, 182, 195

font style mask constants, 182

for loops, 76

FORMAT (library global variable), 180, 182, 196, 197, 202, 221

found_in (library property), 20, 42, 43, 44, 47, 88, 122, 183, 184

fuses (see also daemons), 101

_Future Boy!_ (Hugo game), 16, 220

game loop, 54, 126, 127, 128, 129, 170, 171, 257, 258, 286

Garza, Miguel, 3

GetInput (library routine), 195

GMD, 3

grammar definition, 5, 107, 108, 113, 235

grammar table, 113, 126, 226, 235, 236, 237, 245, 255, 258, 274, 287

GROUPPLURALS_F (printing format mask constant), 182

hasgraphics (display object property), 45, 146, 154, 187, 260

hasvideo (display object property), 146, 187, 261

Hello, Sailor!, 18, 237, 238

her_obj (library global variable), 181, 193

HERE_WORD (library constant), 182

hexadecimal numbers, 58, 163, 286

hidden (library attribute), 40, 179, 187

higher (library routine), 22, 202

him_obj (library global variable), 181, 193

holding (library property), 42, 44, 97, 132, 158, 167, 178, 184, 192, 193

hours:minutes, 233

HoursMinutes (library routine), 195

Hugo Library, 2, 36, 210

Hugo License, 2

hugofix.g (library file), 6, 28

hugofix.h (library file), 6, 28, 217

hugolib.h (library file), 5, 6, 28, 34, 39, 42, 43, 59, 60, 62, 79, 85, 93, 95, 97, 99, 102, 103, 104, 114, 118, 120, 121, 122, 123, 126, 127, 128, 130, 146, 150, 151, 160, 170, 187, 188, 197, 206, 210, 216, 217

identical objects, 94, 122, 139, 141, 142

IF Archive, 3

if-elseif, 74, 161

ignore_response (library property), 45, 186

in_scope (library property), 44, 101, 122, 184, 200

in_to (library property), 44, 131, 185

IN_WORD (library constant), 182

Indent (library routine), 196

INDENT_SIZE (library global variable), 180, 196

Inform, 2, 4, 220

Init (junction routine), 18, 93, 126, 139, 171, 227

initial_desc (library property), 44, 184, 186, 187, 201

InList (library routine), 196

InsertWord (library routine), 196

inv_desc (library property), 45, 186, 201

IS_WORD (library constant), 182

IsorAre (library routine), 191

IsPossibleXobject (library routine), 196

it_obj (library global variable), 181, 193

ITALIC_OFF (font style mask constant), 182

ITALIC_ON (font style mask constant), 182

Jenness, Jeff, 3

Jones, Doug, 3

junction routines, 117, 127, 128, 189, 226, 227

key_object (library property), 45, 97, 124, 125, 186

Kinder, David, 3

known (library attribute), 39, 122, 179, 199, 212, 213

Lash, Bill, 3

last_object (library global variable), 181

LEFT_ARROW (library constant), 182

legal information, 2

library files, 3, 10, 16, 20, 27, 28, 50, 82, 111, 148, 188, 217

light (library attribute), 20, 39, 60, 66, 94, 130, 135, 179, 181, 194, 195, 199

light_source (library global variable), 181, 195, 199

limit settings (compiler), 12, 13, 16, 28, 30

linelength (display object property), 45, 60, 146, 187

Linux, 3, 7

list_contents (library property), 44, 184

LIST_F (printing format mask constant), 182, 197

list_nest (library global variable), 181

ListObjects (library routine), 181, 197, 202

living (library attribute), 39, 179

location (global variable, compiler-defined), 92

lockable (library attribute), 39, 45, 98, 108, 179, 186

locked (library attribute), 39, 42, 77, 78, 86, 87, 145, 179

long_desc (library property), 42, 44, 48, 49, 97, 130, 131, 135, 184, 194

lower (library routine), 203

MacDonald, Alan, 3

Macintosh, 3, 5, 6, 7, 63, 219

Main (junction routine), 18, 19, 94, 100, 108, 126, 127, 137, 227, 258

MATCH_FOREGROUND (color constant), 60, 182

MatchPlural (library routine), 129, 191

MatchSubject (library routine), 192

mathematical operators, 64

MAX_RANK (library global variable), 180

MAX_SCORE (library global variable), 180

MAX_SCRIPTS (library constant), 182, 205

MAX_WORDS (library constant), 182

MAXALIASES (compiler limit setting), 12, 208

MAXARRAYS (compiler limit setting), 12, 208

MAXATTRIBUTES (compiler limit setting), 12, 208, 253

MAXCONSTANTS (compiler limit setting), 12, 208

MAXDICT (compiler limit setting), 12, 13, 209

MAXDICTEXTEND (compiler limit setting), 13, 72, 73, 160, 209, 226

MAXEVENTS (compiler limit setting), 13, 209

MAXFLAGS (compiler limit setting), 13, 209

MAXGLOBALS (compiler limit setting), 12, 208

MAXLABELS (compiler limit setting), 13, 209

MAXLOCALS (compiler limit setting), 12, 208

MAXOBJECTS (compiler limit setting), 13, 16, 30, 31, 209

MAXPROPERTIES (compiler limit setting), 13, 209

MAXROUTINES (compiler limit setting), 13, 209

Mayo, Cena, 3, 220

McGrew, Jesse, 3

Menichelli, John, 3

Menu (library routine), 181, 197, 206

MENU_BGCOLOR (library constant), 183

MENU_SELECTBGCOLOR (library constant), 183

MENU_SELECTCOLOR (library constant), 183

MENU_TEXTCOLOR (library constant), 183

menuitem (library array), 181

Merrick, Iain, 3

Message (library routine), 197

misc (library property), 45, 184

mobile (library attribute), 39, 144, 179

mod (library routine), 162, 203

mouse input, 151, 219

MOUSE_CLICK (library constant), 151, 182

moved (library attribute), 39, 40, 179

MovePlayer (library routine), 143, 194, 198, 211

multiple lines, 24, 31

music resources, 155, 166

MIDI, 152, 291

MOD/S3M/XM, 152, 166, 291

MP3, 152, 291

n_to (library property), 44, 47, 48, 86, 131, 137, 185

name (property, compiler-defined), 33, 48, 85, 158

ne_to (library property), 44, 185

need_newline (library global variable), 181

needs_repaint (display object property), 147, 187

Nelson, Graham, 2, 4, 220

Newland, Jim, 3

newsgroups

_rec.arts.int-fiction_, 3, 220

_rec.games.int-fiction_, 3, 220

Nichols, Jerome, 3

NO_AUX_MATH (library compilation flag), 206

NO_FUSES (library compilation flag), 206

NO_MENUS (library compilation flag), 206

NO_OBJLIB (library compilation flag), 206

NO_RECORDING (library compilation flag), 206

NO_SCRIPTS (library compilation flag), 206

NO_STRING_ARRAYS (library compilation flag), 206

NO_VERBS (library compilation flag), 206

NO_XVERBS (library compilation flag), 206

NOINDENT_F (printing format mask constant), 182, 196

NORECURSE_F (printing format mask constant), 182, 197

noun (property, compiler-defined), 20, 24, 42, 43, 45, 46, 51, 97, 108, 113, 118, 138, 183

number_scripts (library global variable), 181

NumberWord (library routine), 99, 198

nw_to (library property), 44, 185

object (global variable, compiler-defined), 34, 43, 53, 89, 109, 110, 117, 167, 168, 180, 245, 287

object library (objlib.h), 130, 131, 136, 137, 138, 139, 141, 142, 145, 213

object specifications (grammar), 109, 110

object table, 12, 37, 242, 244, 251, 255, 261, 262, 265

object tree, 16, 34, 35, 36, 37, 38, 44, 49, 51, 122, 130, 143, 157, 161, 163, 166, 171, 174, 184, 212, 215

ObjectIs (library routine), 199

ObjectisKnown (library routine), 122, 189, 199

ObjectisLight (library routine), 64, 199

objects

definition, 33, 37, 40

objects (global variable, compiler-defined), 34, 54, 117, 180, 226, 242, 252, 265

objlib.h (library file), 5, 50, 93, 94, 111, 130, 185, 197, 206

ObjWord (library routine), 199

obstacle (library global variable), 181

old_location (library global variable), 94, 181

oldword (library array), 181

ON_WORD (library constant), 182

open (library attribute), 39, 41, 42, 46, 48, 49, 65, 77, 78, 97, 122, 170, 177, 179, 186

openable (library attribute), 39, 49, 98, 179, 186

order of operations, 64

order_response (library property), 45, 123, 128, 186

out_to (library property), 44, 185

override_indent (library global variable), 181

packing list, 4, 9

Palm, 3

Parse (junction routine), 115, 118, 119, 126, 199, 227, 233

parse$, 71, 72, 110, 112, 119, 120, 129, 160, 168, 174, 175, 228, 233, 234, 275, 283, 285, 287, 288

parse_rank (library array), 181

parse_rank (library property), 44, 181, 184, 212

ParseError (junction routine), 119, 120, 128, 227, 234

parser

engine parser, 118, 283

parser errors, 128, 194, 233, 234

parsing, 13, 14, 111, 115, 119, 121, 189, 190, 196, 211, 212, 233, 234

PauseScript (library routine), 103, 205

Penney, Jason C., 3

Perform (junction routine), 124, 125, 127, 227

picture resources (graphics, images), 153, 154, 169

JPEG, 152, 290

Pini, Giacomo, 3

platform (library attribute), 39, 40, 121, 136, 179, 183, 184

player_person (library global variable), 133, 180

Plotkin, Andrew, 3

plural (library attribute), 133, 191, 192

plural objects, 39, 139, 140, 141, 145, 179

Pocket PC (WinCE), 3

pointer_x (display object property), 146, 151, 187

pointer_y (display object property), 146, 151, 187

Pontious, Andrew, 3

postfix operators, 66, 67

pow (library routine), 203

prefix operators, 66, 67

PreParse (library routine), 119, 189, 199

preposition (property, compiler-defined), 138

PrintEndGame (library routine), 121, 189, 199

printing format mask constants, 182

printing text, 22, 56, 57, 58, 59, 60, 61, 63, 76, 167, 175, 180, 186, 238, 241, 245, 251, 274, 275, 284

formatting, 56, 61, 62, 83

printing numbers, 58, 66, 67, 68, 80, 84, 167

special characters, 62, 63, 95, 261

printing to an array, 175, 275, 277

PrintScore (library routine), 189, 200

PrintStatusLine (library routine), 94, 126, 200

prompt (global variable, compiler-defined), 54, 93

pronoun (library property), 44, 45, 132, 184

PROP_OFF (font style mask constant), 62, 182

PROP_ON (font style mask constant), 180, 182

properties, 20, 42, 43, 51, 83, 86, 87, 90, 91, 127, 148, 187, 188, 201, 209, 212, 231, 244, 251, 252, 256

additive, 91

aliases, 45

compiler-defined (engine properties), 33, 43, 48, 85, 108, 138, 140, 158

complex, 43, 244, 245, 252

definition, 43, 88, 91

routines, 43, 83, 86, 90, 91, 127, 148, 187, 188, 201, 209, 231, 244, 251, 256

property table, 12, 47, 242, 244, 245, 251, 252

PropertyList (library routine), 200

punctuation (parser), 112

PutInScope (library routine), 184, 200

quiet (library attribute), 40, 179

random numbers, 170, 175, 212, 213, 228, 239, 240, 282

ranking (library array), 181

Ravindran, Vikram, 3

reach (library property), 12, 44, 75, 184, 193

react_after (library property), 44, 127, 185

react_before (library property), 44, 127, 185

readable (library attribute), 39, 179

removals, 112

RemoveFromScope (library routine), 184, 201

replace_pronoun (library array), 181

replacement (of routines, classes, objects), 50, 82

resource.h (library file), 6, 153, 154, 155

resources, 152, 153, 154, 155, 166, 169, 174, 249, 290, 291

ResumeScript (library routine), 103, 205

return values, 18, 20, 54

default, 86

RIGHT_ARROW (library constant), 182

Roberts, Mike, 2, 220

room class, 50, 130

routines

addresses, 21, 22, 43, 52, 88, 158, 236, 244, 279, 284

definition, 82

RunScripts (library routine), 94, 95, 103, 104, 126, 205, 206

s_to (library property), 44, 131, 137, 185

savefile format, 262

scenery class, 135

Schmidl, Gunther, 3

score (library global variable), 19, 93, 180, 181, 200

screenheight (display object property), 45, 146, 147, 154, 187

screenwidth (display object property), 45, 146, 148, 154, 187

Script (library routine), 102, 103, 205, 211

scriptdata (library array), 181

se_to (library property), 44, 185

self (global variable, compiler-defined), 54, 95, 99

serial$, 71, 174, 229, 275, 285

SetObjWord (library routine), 189, 201

setscript (library array), 181

shell game (shell.hug), 6, 37, 51, 60, 93, 94

Sherwin, Robb, 4

short_desc (library property), 20, 42, 44, 45, 97, 184, 185, 186, 187, 201

ShortDescribe (library routine), 201

size (library property), 42, 43, 44, 46, 85, 185

SkipScript (library routine), 104, 205

SL_BGCOLOR (library global variable), 93, 180

SL_TEXTCOLOR (library global variable), 93, 180

sound resources, 155, 174

wave files, 152, 174

speaking (library global variable), 95, 112, 181

SpeakTo (junction routine), 122, 123, 227

special words, 126, 226, 248

special words table, 248

SpecialDesc (library routine), 201, 202

static (library attribute), 13, 20, 39, 98, 108, 129, 130, 135, 145, 155, 179, 208, 233

statusline_height (display object property), 45, 147, 187

STATUSTYPE (library global variable), 93, 180, 200

string arrays, 70, 71, 72, 110, 174, 204

routines, 71, 72, 80, 81, 203, 204

StringCompare (library routine), 71, 72, 80, 81, 203, 204

StringCopy (library routine), 71, 72, 203

StringDictCompare (library routine), 72, 204

StringEqual (library routine), 71, 204

StringLength (library routine), 71, 204

StringPrint (library routine), 71, 72, 80, 204

sw_to (library property), 44, 185

switchable (library attribute), 39, 179

switchedon (library attribute), 39, 179

synonyms, 113

system.h (library file), 6, 175

system_status (global variable, compiler-defined), 54, 117, 153, 175, 180, 290, 291

TADS, 2, 220

Tate, Christopher, 4

Tessman, Dean, 4

text

color, 59, 159

formatting, 56, 61, 62

Latin-1 encoding, 62, 63

special characters, 63, 95, 261

TEXTCOLOR (library global variable), 19, 93, 180

them_obj (library global variable), 181, 193

Tilford, Mark J., 4

title_caption (display object property), 45, 146, 187

transparent (library attribute), 20, 40, 179, 224

Turnbull, Colin, 3

type (library property), 44, 131, 185

u_to (library property), 44, 185

UNDERLINE_OFF (font style mask constant), 62, 182

UNDERLINE_ON (font style mask constant), 62, 182

unfriendly (library attribute), 39, 179

Unix, 3, 5, 7, 9, 11, 13, 14, 16, 61, 63, 79, 213, 261

UP_ARROW (library constant), 182

variables

global, 53

compiler-defined (engine globals), 53, 54, 60, 92, 95, 99, 109, 127, 141, 190, 245, 287

enumerating, 56

local, 53

Vece, Paolo, 4

vehicle class, 137, 138

verb stub routines, 6, 188, 217

verblib.g (library file), 5, 28, 107, 111

verblib.h (library file), 5, 28, 43, 188, 197

verbosity (library global variable), 181

verbroutine (global variable, compiler-defined), 54, 89, 127, 141, 245

verbroutines, 5, 6, 43, 44, 89, 104, 110, 117, 123, 127, 176, 178, 180, 183, 188, 190, 227

DoAsk, 133, 134, 188

DoAskQuestion, 188

DoBrief, 188

DoClose, 188

DoDrink, 188

DoDrop, 123, 140, 188

DoEat, 89, 90, 188

DoEmpty, 188

DoEnter, 107, 188

DoExit, 107, 188

DoGet, 43, 90, 91, 98, 107, 108, 110, 111, 116, 123, 124, 125, 129, 140, 188, 235, 236, 245

DoGive, 133, 134, 188

DoGo, 87, 188

DoHello, 188

DoHit, 188

DoInventory, 124, 188

DoListen, 188

DoLock, 98, 188

DoLook, 140, 188

DoLookAround, 188

DoLookIn, 188

DoLookThrough, 188

DoLookUnder, 97, 188

DoMove, 188

DoOpen, 137, 188

DoPutIn, 90, 140, 188

DoPutOnGround, 188

DoQuit, 188

DoRecordOnOff, 188

DoRestart, 188

DoRestore, 188

DoSave, 108, 188

DoScore, 188

DoScriptOnOff, 188

DoShow, 133, 134, 188

DoSit, 188

DoSuperbrief, 188

DoSwitchOff, 188

DoSwitchOn, 188

DoTakeOff, 107, 188

DoTalk, 188

DoTell, 133, 134, 188

DoUndo, 188

DoUnlock, 188

DoVague, 107, 108, 143, 188

DoVerbose, 188

DoWait, 104, 181, 188

DoWaitforChar, 188

DoWaitUntil, 188

DoWear, 188

verbs, 92

verbstub.g (library file), 6

verbstub.h (library file), 6, 188, 217

VerbWord (library routine), 202

video resources (movies), 155

AVI, 152

MPEG, 152

visited (library attribute), 39, 40, 94, 179

w_to (library property), 44, 131, 185

WhatsIn (library routine), 40, 180, 197, 201, 202

when_closed (library property), 45, 186, 201

when_open (library property), 45, 97, 98, 186, 201

while loops, 75, 269, 270

window.h (library file), 6, 148

windowlines (display object property), 45, 146, 187

windows, 45, 61, 146, 147, 148, 154, 159, 165, 187, 281, 286

Windows (Microsoft Windows), 3, 5, 6, 7, 9, 11, 14, 147, 152, 153, 213, 214, 219, 261

word array, 70, 77, 78, 114, 115, 151, 164, 168, 194, 195, 196, 201, 233, 239, 251, 259, 282, 283, 285

workflag (library attribute), 40, 180

worn (library attribute), 39, 179, 199

xobject (global variable, compiler-defined), 190, 287

xverbs, 92

YesorNo (library routine), 202

*ABOUT THE AUTHOR*

Kent Tessman is a filmmaker and accidental game designer.

**The General Coffee Company Press +
**Toronto, Canada


// EOF //
